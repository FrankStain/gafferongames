<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gaffer On Games</title>
    <link>http://127.0.0.1:1313/</link>
    <description>Recent content on Gaffer On Games</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © Glenn Fiedler, 2004 - 2018</copyright>
    <lastBuildDate>Sun, 26 Feb 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://127.0.0.1:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why can&#39;t I send UDP packets from a browser?</title>
      <link>http://127.0.0.1:1313/post/why_cant_i_send_udp_packets_from_a_browser/</link>
      <pubDate>Sun, 26 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/why_cant_i_send_udp_packets_from_a_browser/</guid>
      <description>Premise In 2017 the most popular web games like agar.io are networked via WebSockets over TCP. If a UDP equivalent of WebSockets could be incorporated into browsers, it would greatly improve the networking of these games.
Background Web browsers are built on top of HTTP, which is a stateless request/response protocol initially designed for serving static web pages. HTTP is built on top of TCP, a low-level protocol which guarantees data sent over the internet arrives reliably, and in the same order it was sent.</description>
    </item>
    
    <item>
      <title>Client Server Connection</title>
      <link>http://127.0.0.1:1313/post/client_server_connection/</link>
      <pubDate>Wed, 28 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/client_server_connection/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
So far in this article series we&amp;rsquo;ve discussed how games read and write packets, how to unify packet read and write into a single function, how to fragment and re-assemble packets, and how to send large blocks of data over UDP.
Now in this article we&amp;rsquo;re going to bring everything together and build a client/server connection on top of UDP.</description>
    </item>
    
    <item>
      <title>Reliable Ordered Messages</title>
      <link>http://127.0.0.1:1313/post/reliable_ordered_messages/</link>
      <pubDate>Thu, 15 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/reliable_ordered_messages/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
Many people will tell you that implementing your own reliable message system on top of UDP is foolish. After all, why reimplement TCP?
But why limit ourselves to how TCP works? But there are so many different ways to implement reliable-messages and most of them work nothing like TCP!
So let&amp;rsquo;s get creative and work out how we can implement a reliable message system that&amp;rsquo;s better and more flexible than TCP for real-time games.</description>
    </item>
    
    <item>
      <title>Sending Large Blocks of Data</title>
      <link>http://127.0.0.1:1313/post/sending_large_blocks_of_data/</link>
      <pubDate>Mon, 12 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/sending_large_blocks_of_data/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In the previous article we implemented packet fragmentation and reassembly so we can send packets larger than MTU.
This approach works great when the data block you&amp;rsquo;re sending is time critical and can be dropped, but in other cases you need to send large blocks of quickly and reliably over packet loss, and you need the data to get through.</description>
    </item>
    
    <item>
      <title>Packet Fragmentation and Reassembly</title>
      <link>http://127.0.0.1:1313/post/packet_fragmentation_and_reassembly/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/packet_fragmentation_and_reassembly/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In the previous article we discussed how to unify packet read and write into a single serialize function and added a bunch of safety features to packet read.
Now we are ready to start putting interesting things in our packets and sending them over the network, but immediately we run into an interesting question: how big should our packets be?</description>
    </item>
    
    <item>
      <title>Serialization Strategies</title>
      <link>http://127.0.0.1:1313/post/serialization_strategies/</link>
      <pubDate>Sun, 04 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/serialization_strategies/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In the previous article, we created a bitpacker but it required manual checking to make sure reading a packet from the network is safe. This is a real problem because the stakes are particularly high - a single missed check creates a vulnerability that an attacker can use to crash your server.
In this article, we&amp;rsquo;re going to transform the bitpacker into a system where this checking is automatic.</description>
    </item>
    
    <item>
      <title>Reading and Writing Packets</title>
      <link>http://127.0.0.1:1313/post/reading_and_writing_packets/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/reading_and_writing_packets/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In this article we&amp;rsquo;re going to explore how AAA multiplayer games like first person shooters read and write packets. We&amp;rsquo;ll start with text based formats then move into binary hand-coded binary formats and bitpacking.
At the end of this article and the next, you should understand exactly how to implement your own packet read and write the same way the pros do it.</description>
    </item>
    
    <item>
      <title>State Synchronization</title>
      <link>http://127.0.0.1:1313/post/state_synchronization/</link>
      <pubDate>Mon, 05 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/state_synchronization/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networked Physics.
In the previous article we discussed techniques for compressing snapshots.
In this article we round out our discussion of networked physics strategies with state synchronization, the third and final strategy in this article series.
State Synchronization What is state synchronization? The basic idea is that, somewhat like deterministic lockstep, we run the simulation on both sides but, unlike deterministic lockstep, we don&amp;rsquo;t just send input, we send both input and state.</description>
    </item>
    
    <item>
      <title>Snapshot Compression</title>
      <link>http://127.0.0.1:1313/post/snapshot_compression/</link>
      <pubDate>Sun, 04 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/snapshot_compression/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networked Physics.
In the previous article we sent snapshots of the entire simulation 10 times per-second over the network and interpolated between them to reconstruct a view of the simulation on the other side.
The problem with a low snapshot rate like 10HZ is that interpolation between snapshots adds interpolation delay on top of network latency. At 10 snapshots per-second, the minimum interpolation delay is 100ms, and a more practical minimum considering network jitter is 150ms.</description>
    </item>
    
    <item>
      <title>Snapshot Interpolation</title>
      <link>http://127.0.0.1:1313/post/snapshot_interpolation/</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/snapshot_interpolation/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networked Physics.
In the previous article we networked a physics simulation using deterministic lockstep. Now, in this article we&amp;rsquo;re going to network the same simulation with a completely different technique: snapshot interpolation.
Background While deterministic lockstep is very efficient in terms of bandwidth, it&amp;rsquo;s not always possible to make your simulation deterministic. Floating point determinism across platforms is hard.
Also, as the player counts increase, deterministic lockstep becomes problematic: you can&amp;rsquo;t simulate frame n until you receive input from all players for that frame, so players end up waiting for the most lagged player.</description>
    </item>
    
    <item>
      <title>Deterministic Lockstep</title>
      <link>http://127.0.0.1:1313/post/deterministic_lockstep/</link>
      <pubDate>Sat, 29 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/deterministic_lockstep/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networked Physics.
In the previous article we explored the physics simulation we&amp;rsquo;re going to network in this article series. In this article specifically, we&amp;rsquo;re going to network this physics simulation using deterministic lockstep.
Deterministic lockstep is a method of networking a system from one computer to another by sending only the inputs that control that system, rather than the state of that system.</description>
    </item>
    
    <item>
      <title>Introduction to Networked Physics</title>
      <link>http://127.0.0.1:1313/post/introduction_to_networked_physics/</link>
      <pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/introduction_to_networked_physics/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to the first article in Networked Physics.
In this article series we&amp;rsquo;re going to network a physics simulation three different ways: deterministic lockstep, snapshot interpolation and state synchronization.
But before we get to this, let&amp;rsquo;s spend some time exploring the physics simulation we’re going to network in this article series:
Your browser does not support the video tag.  Here I’ve setup a simple simulation of a cube in the open source physics engine ODE.</description>
    </item>
    
    <item>
      <title>Collision Response and Coulomb Friction</title>
      <link>http://127.0.0.1:1313/post/collision_response_and_coulomb_friction/</link>
      <pubDate>Sun, 24 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/collision_response_and_coulomb_friction/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to Virtual Go, my project to create a physically accurate computer simulation of a Go board and stones.
So far in this series, we have mathematically defined the go stone, rendered it, determined how it moves and rotates, and discussed how its shape affects how it responds to collisions.
Now in this article we reach our first milestone:
A go stone bouncing and coming to rest on the go board.</description>
    </item>
    
    <item>
      <title>Rotation &amp; Inertia Tensors</title>
      <link>http://127.0.0.1:1313/post/rotation_and_inertia_tensors/</link>
      <pubDate>Sat, 23 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/rotation_and_inertia_tensors/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to Virtual Go, my project to create a physically accurate computer simulation of a Go board and stones.
In the previous article we detected collision between the go stone and the go board. Now we&amp;rsquo;re working up to calculating collision response so the stone bounces and wobbles before coming to rest on the board.
But in order to reach this goal we first need to lay some groundwork.</description>
    </item>
    
    <item>
      <title>Go Stone vs. Go Board</title>
      <link>http://127.0.0.1:1313/post/go_stone_vs_go_board/</link>
      <pubDate>Fri, 22 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/go_stone_vs_go_board/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to Virtual Go, my project to create a physically accurate computer simulation of a Go board and stones.
In this series so far we&amp;rsquo;ve defined the shape of a go stone, rendered it using 3D graphics hardware and simulated how it moves in three dimensions.
Our next goal is for the go stone to bounce and come to rest on the go board.</description>
    </item>
    
    <item>
      <title>How The Go Stone Moves</title>
      <link>http://127.0.0.1:1313/post/how_the_go_stone_moves/</link>
      <pubDate>Thu, 21 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/how_the_go_stone_moves/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to Virtual Go, my project to create a physically accurate computer simulation of a Go board and stones.
In previous articles we mathematically defined the shape of a go stone and tessellated its shape so it can be drawn with 3D graphics hardware.
Now we want to make the go stone move, obeying Newton&amp;rsquo;s laws of motion so the simulation is physically accurate. The stone should be accelerated by gravity and fall downwards.</description>
    </item>
    
    <item>
      <title>Tessellating The Go Stone</title>
      <link>http://127.0.0.1:1313/post/tessellating_the_go_stone/</link>
      <pubDate>Wed, 20 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/tessellating_the_go_stone/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to Virtual Go, my project to create a physically accurate computer simulation of a Go board and stones.
In this article we want to draw the go stone using OpenGL.
Unfortunately we can&amp;rsquo;t just tell the graphics card, &amp;ldquo;Hey! Please draw the intersection of two spheres with radius r and d apart with a bevel torus r1 and r2!&amp;ldquo;, because modern 3D graphics cards work by drawing triangles.</description>
    </item>
    
    <item>
      <title>Shape of The Go Stone</title>
      <link>http://127.0.0.1:1313/post/shape_of_the_go_stone/</link>
      <pubDate>Tue, 19 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/shape_of_the_go_stone/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to Virtual Go, my project to create a physically accurate computer simulation of a Go board and stones.
If you play Go, you know that a biconvex go stone has an interesting wobble when it&amp;rsquo;s placed on the board. This wobble is a direct consequence of its unique shape.
I&amp;rsquo;d like to reproduce this wobble in Virtual Go, so let&amp;rsquo;s to spend some time studying go stone&amp;rsquo;s shape, so we can capture this wobble and simulate it on a computer :)</description>
    </item>
    
    <item>
      <title>Introduction to Virtual Go</title>
      <link>http://127.0.0.1:1313/post/introduction_to_virtual_go/</link>
      <pubDate>Mon, 18 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/introduction_to_virtual_go/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to Virtual Go, my project to create a physically accurate computer simulation of a Go board and stones.
I&amp;rsquo;m a professional game programmer with 15 years experience in the game industry. Over the years I&amp;rsquo;ve worked for Irrational Games, Team Bondi, Pandemic Studios, Sony Santa Monica and most recently Respawn Entertainment. During my career I&amp;rsquo;m extremely proud to have worked on such games as &amp;lsquo;Freedom Force&amp;rsquo;, &amp;lsquo;L.</description>
    </item>
    
    <item>
      <title>Floating Point Determinism</title>
      <link>http://127.0.0.1:1313/post/floating_point_determinism/</link>
      <pubDate>Wed, 24 Feb 2010 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/floating_point_determinism/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
Lately I&amp;rsquo;ve been doing some research into networking game physics simulations via deterministic lockstep methods.
The basic idea is that instead of synchronizing the state of physics objects directly by sending the positions, orientations, velocities etc. over the network, one could synchronize the simulation implicitly by sending just the player inputs.
This is a very attractive synchronization strategy because the amount of network traffic depends on the size of the player inputs instead of the amount of physics state in the world.</description>
    </item>
    
    <item>
      <title>What Every Programmer Needs To Know About Game Networking</title>
      <link>http://127.0.0.1:1313/post/what_every_programmer_needs_to_know_about_game_networking/</link>
      <pubDate>Wed, 24 Feb 2010 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/what_every_programmer_needs_to_know_about_game_networking/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
Have you ever wondered how multiplayer games work?
From the outside it seems magical: two or more players sharing a consistent experience across the network like they actually exist together in the same virtual world.
But as programmers we know the truth of what is actually going on underneath is quite different from what you see. It turns out it&amp;rsquo;s all an illusion.</description>
    </item>
    
    <item>
      <title>Reliability and Congestion Avoidance over UDP</title>
      <link>http://127.0.0.1:1313/post/reliability_ordering_and_congestion_avoidance_over_udp/</link>
      <pubDate>Mon, 20 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/reliability_ordering_and_congestion_avoidance_over_udp/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In the previous article, we added our own concept of virtual connection on top of UDP. In this article we’re going to add reliability, ordering and congestion avoidance to our virtual UDP connection.
The Problem with TCP Those of you familiar with TCP know that it already has its own concept of connection, reliability-ordering and congestion avoidance, so why are we rewriting our own mini version of TCP on top of UDP?</description>
    </item>
    
    <item>
      <title>Virtual Connection over UDP</title>
      <link>http://127.0.0.1:1313/post/virtual_connection_over_udp/</link>
      <pubDate>Wed, 08 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/virtual_connection_over_udp/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In the previous article we sent and received packets over UDP. Since UDP is connectionless, one UDP socket can be used to exchange packets with any number of different computers. In multiplayer games however, we usually only want to exchange packets between a small set of connected computers.
As the first step towards a general connection system, we&amp;rsquo;ll start with the simplest case possible: creating a virtual connection between two computers on top of UDP.</description>
    </item>
    
    <item>
      <title>Sending and Receiving Packets</title>
      <link>http://127.0.0.1:1313/post/sending_and_receiving_packets/</link>
      <pubDate>Fri, 03 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/sending_and_receiving_packets/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In the previous article we discussed options for sending data between computers and decided to use UDP instead of TCP for time critical data.
In this article I am going to show you how to send and receive UDP packets.
BSD sockets For most modern platforms you have some sort of basic socket layer available based on BSD sockets.</description>
    </item>
    
    <item>
      <title>UDP vs. TCP</title>
      <link>http://127.0.0.1:1313/post/udp_vs_tcp/</link>
      <pubDate>Wed, 01 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/udp_vs_tcp/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In this article we start with the most basic aspect of network programming: sending and receiving data over the network. This is perhaps the simplest and most basic part of what network programmers do, but still it is quite intricate and non-obvious as to what the best course of action is.
You have most likely heard of sockets, and are probably aware that there are two main types: TCP and UDP.</description>
    </item>
    
    <item>
      <title>Networked Physics (2004)</title>
      <link>http://127.0.0.1:1313/post/networked_physics_2004/</link>
      <pubDate>Sat, 04 Sep 2004 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/networked_physics_2004/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Game Physics.
In the previous article we discussed how to use spring-like forces to model basic collision response, joints and motors.
In this article we&amp;rsquo;re going to discuss how to network a physics simulation.
First Person Shooters First person shooter physics are usually very simple. The world is static and players are limited to running around and jumping and shooting.
Because of cheating, first person shooters typically operate on a client-server model where the server is authoritative over physics.</description>
    </item>
    
    <item>
      <title>Spring Physics</title>
      <link>http://127.0.0.1:1313/post/spring_physics/</link>
      <pubDate>Fri, 03 Sep 2004 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/spring_physics/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Game Physics.
In the previous article we discussed how to simulate the motion of rigid bodies in 3D. Now we&amp;rsquo;re going to discuss how to implement spring physics.
The physics behind springs is simple but extremely versatile and useful. You can use springs to link points together to model rope and string, cloth, and even blobs of jelly. Springs can also be used to implement basic collision response, and to create joints that constrain the motion of rigid bodies.</description>
    </item>
    
    <item>
      <title>Physics in 3D</title>
      <link>http://127.0.0.1:1313/post/physics_in_3d/</link>
      <pubDate>Thu, 02 Sep 2004 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/physics_in_3d/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Game Physics.
In the previous article we discussed how to integrate our physics simulation forward at fixed delta time increments, regardless of display framerate.
In this article we are going to simulate motion in three dimensions.
Rigid Bodies We will concentrate on a type of object called a rigid body. Rigid bodies cannot bend, compress or deform in any way. This makes their motion much easier to calculate.</description>
    </item>
    
    <item>
      <title>Fix Your Timestep!</title>
      <link>http://127.0.0.1:1313/post/fix_your_timestep/</link>
      <pubDate>Thu, 10 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/fix_your_timestep/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Game Physics.
In the previous article we discussed how to integrate the equations of motion using a numerical integrator. Integration sounds complicated, but it&amp;rsquo;s just a way to advance the your physics simulation forward by some small amount of time called &amp;ldquo;delta time&amp;rdquo; (or dt for short).
But how to choose this delta time value? This may seem like a trivial subject but in fact there are many different ways to do it, each with their own strengths and weaknesses - so read on!</description>
    </item>
    
    <item>
      <title>Integration Basics</title>
      <link>http://127.0.0.1:1313/post/integration_basics/</link>
      <pubDate>Tue, 01 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/integration_basics/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Game Physics.
If you have ever wondered how the physics simulation in a computer game works then this series of articles will explain it for you. I assume you are proficient with C++ and have a basic grasp of physics and mathematics. Nothing else will be required if you pay attention and study the example source code.
A physics simulation works by making many small predictions based on the laws of physics.</description>
    </item>
    
  </channel>
</rss>