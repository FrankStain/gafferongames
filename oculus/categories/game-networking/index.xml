<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Game Networking on Gaffer On Games</title>
    <link>http://127.0.0.1:1313/categories/game-networking/</link>
    <description>Recent content in Game Networking on Gaffer On Games</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © Glenn Fiedler, 2004 - 2018</copyright>
    <lastBuildDate>Wed, 24 Feb 2010 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://127.0.0.1:1313/categories/game-networking/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Floating Point Determinism</title>
      <link>http://127.0.0.1:1313/post/floating_point_determinism/</link>
      <pubDate>Wed, 24 Feb 2010 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/floating_point_determinism/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
Lately I&amp;rsquo;ve been doing some research into networking game physics simulations via deterministic lockstep methods.
The basic idea is that instead of synchronizing the state of physics objects directly by sending the positions, orientations, velocities etc. over the network, one could synchronize the simulation implicitly by sending just the player inputs.
This is a very attractive synchronization strategy because the amount of network traffic depends on the size of the player inputs instead of the amount of physics state in the world.</description>
    </item>
    
    <item>
      <title>What Every Programmer Needs To Know About Game Networking</title>
      <link>http://127.0.0.1:1313/post/what_every_programmer_needs_to_know_about_game_networking/</link>
      <pubDate>Wed, 24 Feb 2010 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/what_every_programmer_needs_to_know_about_game_networking/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
Have you ever wondered how multiplayer games work?
From the outside it seems magical: two or more players sharing a consistent experience across the network like they actually exist together in the same virtual world.
But as programmers we know the truth of what is actually going on underneath is quite different from what you see. It turns out it&amp;rsquo;s all an illusion.</description>
    </item>
    
    <item>
      <title>Reliability and Congestion Avoidance over UDP</title>
      <link>http://127.0.0.1:1313/post/reliability_ordering_and_congestion_avoidance_over_udp/</link>
      <pubDate>Mon, 20 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/reliability_ordering_and_congestion_avoidance_over_udp/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In the previous article, we added our own concept of virtual connection on top of UDP. In this article we’re going to add reliability, ordering and congestion avoidance to our virtual UDP connection.
The Problem with TCP Those of you familiar with TCP know that it already has its own concept of connection, reliability-ordering and congestion avoidance, so why are we rewriting our own mini version of TCP on top of UDP?</description>
    </item>
    
    <item>
      <title>Virtual Connection over UDP</title>
      <link>http://127.0.0.1:1313/post/virtual_connection_over_udp/</link>
      <pubDate>Wed, 08 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/virtual_connection_over_udp/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In the previous article we sent and received packets over UDP. Since UDP is connectionless, one UDP socket can be used to exchange packets with any number of different computers. In multiplayer games however, we usually only want to exchange packets between a small set of connected computers.
As the first step towards a general connection system, we&amp;rsquo;ll start with the simplest case possible: creating a virtual connection between two computers on top of UDP.</description>
    </item>
    
    <item>
      <title>Sending and Receiving Packets</title>
      <link>http://127.0.0.1:1313/post/sending_and_receiving_packets/</link>
      <pubDate>Fri, 03 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/sending_and_receiving_packets/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In the previous article we discussed options for sending data between computers and decided to use UDP instead of TCP for time critical data.
In this article I am going to show you how to send and receive UDP packets.
BSD sockets For most modern platforms you have some sort of basic socket layer available based on BSD sockets.</description>
    </item>
    
    <item>
      <title>UDP vs. TCP</title>
      <link>http://127.0.0.1:1313/post/udp_vs_tcp/</link>
      <pubDate>Wed, 01 Oct 2008 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/udp_vs_tcp/</guid>
      <description>Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
In this article we start with the most basic aspect of network programming: sending and receiving data over the network. This is perhaps the simplest and most basic part of what network programmers do, but still it is quite intricate and non-obvious as to what the best course of action is.
You have most likely heard of sockets, and are probably aware that there are two main types: TCP and UDP.</description>
    </item>
    
  </channel>
</rss>