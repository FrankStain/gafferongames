<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Building a Game Network Protocol on Gaffer On Games</title>
    <link>http://127.0.0.1:1313/categories/building-a-game-network-protocol/</link>
    <description>Recent content in Building a Game Network Protocol on Gaffer On Games</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © Glenn Fiedler, 2004 - 2018</copyright>
    <lastBuildDate>Wed, 28 Sep 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://127.0.0.1:1313/categories/building-a-game-network-protocol/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Client Server Connection</title>
      <link>http://127.0.0.1:1313/post/client_server_connection/</link>
      <pubDate>Wed, 28 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/client_server_connection/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
So far in this article series we&amp;rsquo;ve discussed how games read and write packets, how to unify packet read and write into a single function, how to fragment and re-assemble packets, and how to send large blocks of data over UDP.
Now in this article we&amp;rsquo;re going to bring everything together and build a client/server connection on top of UDP.</description>
    </item>
    
    <item>
      <title>Reliable Ordered Messages</title>
      <link>http://127.0.0.1:1313/post/reliable_ordered_messages/</link>
      <pubDate>Thu, 15 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/reliable_ordered_messages/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
Many people will tell you that implementing your own reliable message system on top of UDP is foolish. After all, why reimplement TCP?
But why limit ourselves to how TCP works? But there are so many different ways to implement reliable-messages and most of them work nothing like TCP!
So let&amp;rsquo;s get creative and work out how we can implement a reliable message system that&amp;rsquo;s better and more flexible than TCP for real-time games.</description>
    </item>
    
    <item>
      <title>Sending Large Blocks of Data</title>
      <link>http://127.0.0.1:1313/post/sending_large_blocks_of_data/</link>
      <pubDate>Mon, 12 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/sending_large_blocks_of_data/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In the previous article we implemented packet fragmentation and reassembly so we can send packets larger than MTU.
This approach works great when the data block you&amp;rsquo;re sending is time critical and can be dropped, but in other cases you need to send large blocks of quickly and reliably over packet loss, and you need the data to get through.</description>
    </item>
    
    <item>
      <title>Packet Fragmentation and Reassembly</title>
      <link>http://127.0.0.1:1313/post/packet_fragmentation_and_reassembly/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/packet_fragmentation_and_reassembly/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In the previous article we discussed how to unify packet read and write into a single serialize function and added a bunch of safety features to packet read.
Now we are ready to start putting interesting things in our packets and sending them over the network, but immediately we run into an interesting question: how big should our packets be?</description>
    </item>
    
    <item>
      <title>Serialization Strategies</title>
      <link>http://127.0.0.1:1313/post/serialization_strategies/</link>
      <pubDate>Sun, 04 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/serialization_strategies/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In the previous article, we created a bitpacker but it required manual checking to make sure reading a packet from the network is safe. This is a real problem because the stakes are particularly high - a single missed check creates a vulnerability that an attacker can use to crash your server.
In this article, we&amp;rsquo;re going to transform the bitpacker into a system where this checking is automatic.</description>
    </item>
    
    <item>
      <title>Reading and Writing Packets</title>
      <link>http://127.0.0.1:1313/post/reading_and_writing_packets/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/post/reading_and_writing_packets/</guid>
      <description>Introduction Hi, I’m Glenn Fiedler and welcome to Building a Game Network Protocol.
In this article we&amp;rsquo;re going to explore how AAA multiplayer games like first person shooters read and write packets. We&amp;rsquo;ll start with text based formats then move into binary hand-coded binary formats and bitpacking.
At the end of this article and the next, you should understand exactly how to implement your own packet read and write the same way the pros do it.</description>
    </item>
    
  </channel>
</rss>