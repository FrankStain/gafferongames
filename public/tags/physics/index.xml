<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Physics on Gaffer On Games</title>
    <link>http://173.255.195.190/gafferongames/tags/physics/</link>
    <description>Recent content in Physics on Gaffer On Games</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© The Network Protocol Company, Inc.</copyright>
    <lastBuildDate>Wed, 01 Jun 2005 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://173.255.195.190/gafferongames/tags/physics/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Integration Basics</title>
      <link>http://173.255.195.190/gafferongames/post/integration_basics/</link>
      <pubDate>Wed, 01 Jun 2005 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/integration_basics/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m &lt;a href=&#34;http://173.255.195.190/gafferongames/about&#34;&gt;Glenn Fiedler&lt;/a&gt; and welcome to the first article in &lt;strong&gt;&lt;a href=&#34;http://173.255.195.190/gafferongames/categories/game-physics/&#34;&gt;Game Physics&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If you have ever wondered how the physics simulation in a computer game works then this series of articles will explain it for you. I assume you are proficient with C++ and have a basic grasp of physics and mathematics. Nothing else will be required if you pay attention and study the example source code.&lt;/p&gt;

&lt;p&gt;A physics simulation works by making many small predictions based on the laws of physics. These predictions are actually quite simple, and basically boil down to something like &amp;ldquo;that the object is here, and is traveling this fast in that direction, so in a short amount of time it should be over there&amp;rdquo;. We perform these predictions using a mathematical technique called integration.&lt;/p&gt;

&lt;p&gt;Exactly how to implement this integration is the subject of this article.&lt;/p&gt;

&lt;h2 id=&#34;integrating-the-equations-of-motion&#34;&gt;Integrating the Equations of Motion&lt;/h2&gt;

&lt;p&gt;You may remember from high school or university physics that force equals mass times acceleration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    f = ma
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can switch this around to see that acceleration is force divided by mass. This makes intuitive sense because the more an object weighs, the less acceleration it receives from the same amount of force. Heavier objects are harder to throw.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    a = f/m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since acceleration is the rate of change in velocity over time, we can also say that force divided by mass is the rate of change in velocity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    dv/dt = a = F/m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, velocity is the rate of change in position over time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    dx/dt = v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means that if we know the current position and velocity of an object, and the forces that will be applied to it, we can integrate to find its position and velocity at some time in the future.&lt;/p&gt;

&lt;h2 id=&#34;numerical-integration&#34;&gt;Numerical Integration&lt;/h2&gt;

&lt;p&gt;For those who have not formally studied differential equations at university, take heart for you are in just as good a position as those who have! This is because we are not going to solve the differential equations as you would normally do in first year mathematics, instead we are going to &lt;strong&gt;numerically integrate&lt;/strong&gt; to find the solution.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how numerical integration works. First, start at an initial position and velocity, then take a small step forward to find the velocity and position at a future time. Then repeat this, moving forward in small discrete time steps, using the result of the previous calculation as the starting point for the next.&lt;/p&gt;

&lt;p&gt;But how do we find the change in velocity and position each step?&lt;/p&gt;

&lt;p&gt;The answer lies in the &lt;strong&gt;equations of motion&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Lets call our current time &lt;strong&gt;t&lt;/strong&gt;, and the time step &lt;strong&gt;dt&lt;/strong&gt; or &amp;lsquo;delta time&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Now we can put the equations of motion in a form anyone can understand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    acceleration = force / mass

    change in position = velocity * dt

    change in velocity = acceleration * dt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes intuitive sense because if you&amp;rsquo;re in a car traveling 60 kilometers per-hour, in one hour you&amp;rsquo;ll be 60 kilometers further down the road. Similarly, a car accelerating 10 kilometers per-hour per-second from a standing start will be travelling 100 kilometers per-hour in 10 seconds.&lt;/p&gt;

&lt;p&gt;Of course this logic only holds when acceleration and velocity are constant. But even when they&amp;rsquo;re not, it&amp;rsquo;s still a decent approximation to start with.&lt;/p&gt;

&lt;p&gt;Lets put this into code. Starting with a stationary object at the origin weighing one kilogram, we apply a constant force of 10 newtons and step forward with a time step of one second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    double t = 0.0;
    float dt = 1.0f;

    float velocity = 0.0f;
    float position = 0.0f;
    float force = 10.0f;
    float mass = 1.0f;

    while ( t &amp;lt;= 10.0f )
    {
        position = position + velocity * dt;
        velocity = velocity + ( force / mass ) * dt;
        t += dt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    t=0:    position = 0      velocity = 0
    t=1:    position = 0      velocity = 10
    t=2:    position = 10     velocity = 20
    t=3:    position = 30     velocity = 30
    t=4:    position = 60     velocity = 40
    t=5:    position = 100    velocity = 50
    t=6:    position = 150    velocity = 60
    t=7:    position = 210    velocity = 70
    t=8:    position = 280    velocity = 80
    t=9:    position = 360    velocity = 90
    t=10:   position = 450    velocity = 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, at at each step we know both the position and velocity of the object. This is numerical integration.&lt;/p&gt;

&lt;h2 id=&#34;why-euler-integration-is-not-always-so-great&#34;&gt;Why Euler Integration is not (always) so great&lt;/h2&gt;

&lt;p&gt;What we just did is called Euler Integration. Specifically it is a type of euler integration called &lt;strong&gt;explicit euler&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;To save you future embarrassment, I must point out now that Euler is pronounced &amp;ldquo;Oiler&amp;rdquo; not &amp;ldquo;yew-ler&amp;rdquo; as it is the last name of the Swiss mathematician &lt;a href=&#34;https://en.wikipedia.org/wiki/Leonhard_Euler&#34;&gt;Leonhard Euler&lt;/a&gt; who first discovered this technique.&lt;/p&gt;

&lt;p&gt;Euler integration is the most basic of numerical integration techniques. It is only 100% accurate when the rate of change is constant over the timestep.&lt;/p&gt;

&lt;p&gt;Since acceleration is constant in the example above, the integration of velocity is without error. However, we are also integrating velocity to get the position each step, and velocity is increasing 10 meters per-second per-second due to acceleration, so velocity is definitely &lt;em&gt;not&lt;/em&gt; constant. This means there is error in the integrated position.&lt;/p&gt;

&lt;p&gt;Just how large is this error? Lets find out!&lt;/p&gt;

&lt;p&gt;There is a closed form solution for how an object moves under constant acceleration. We can use this equation to compare our numerically integrated position with the exact result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s = ut + 0.5at^2
    s = 0.0*t + 0.5at^2
    s = 0.5(10)(10^2)
    s = 0.5(10)(100)
    s = 500 meters
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After 10 seconds, the object should have moved 500 meters, but explicit euler integration gave a result of 450 meters. That&amp;rsquo;s 50 meters off after just 10 seconds!&lt;/p&gt;

&lt;p&gt;This sounds really, really bad, but it&amp;rsquo;s not common for games to step physics forward with such large time steps. In fact, physics usually steps forward at something closer to the display framerate. Otherwise, how would the physics simulation react to player input?&lt;/p&gt;

&lt;p&gt;Stepping forward with &lt;strong&gt;dt&lt;/strong&gt; = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;100&lt;/sub&gt; gives a result much closer to the exact value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
    t=10:   position = 450    velocity = 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;(todo: rewrite paragraph below, it&amp;rsquo;s too ominous. error exists, but it&amp;rsquo;s not the end of the world for most game simulations)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;However, no matter how much you reduce your timestep, the simple truth is that the error will always be there and that it will keep increasing over time. Given that this is an extremely simple simulation, imagine something as simple as adding a torque curve to the car, or adding gears. Suddenly the car’s acceleration is not a constant, it changes over time. Now there is error when integrating the velocity, and these errors are magnified even further when integrating the position.&lt;/p&gt;

&lt;h2 id=&#34;many-different-integration-methods-exist&#34;&gt;Many different integration methods exist&lt;/h2&gt;

&lt;p&gt;You can see that explicit euler has a large amount of error in the case above, but it’s a gross simplification to say that it&amp;rsquo;s terrible or that it should never be used. Just be aware of its shortcomings. There are also several other Euler method variants with different properties to consider.&lt;/p&gt;

&lt;p&gt;For example, semi-implicit euler (symplectic euler) is a method that changes the point of time where velocity is sampled. It adds acceleration to velocity first, and then updates position from that updated velocity vs. the other way around. This small change makes the integrator more stable at the cost of losing energy over time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while ( t &amp;lt;= 10.0f )
    {
        position = position + velocity * dt;
        velocity = velocity + ( force / mass ) * dt;
        t = t + dt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A completely different option is implicit or &lt;a href=&#34;http://web.mit.edu/10.001/Web/Course_Notes/Differential_Equations_Notes/node3.html&#34;&gt;backwards euler&lt;/a&gt;. This method is better for simulating stiff equations (eg. stiff springs) that break down and become unstable with other methods, but it&amp;rsquo;s much more involved and requires solving a system of equations per-timestep. It&amp;rsquo;s not often used for game physics.&lt;/p&gt;

&lt;p&gt;Another option for greater accuracy and less memory when simulating a large number of particles is &lt;a href=&#34;https://en.wikipedia.org/wiki/Verlet_integration&#34;&gt;verlet integration&lt;/a&gt;, specifically velocity-less verlet integration. This integrator does not require storing velocity per-particle, as it derives velocity from the two most recent position values. This makes collision detection and position fix-up (eg. pushing particles out of collision with a wall) easy to implement and saves a bunch of memory when you have lots of particles.&lt;/p&gt;

&lt;p&gt;There are of course many other integrators. In this article I’m going to focus on the &amp;ldquo;RK4&amp;rdquo; integrator: Runge Kutta order 4, so named for the two german mathematicians that discovered it: &lt;a href=&#34;https://en.wikipedia.org/wiki/Carl_David_Tolmé_Runge&#34;&gt;Carl Runge&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Martin_Wilhelm_Kutta&#34;&gt;Martin Kutta&lt;/a&gt;. This is not to suggest that this is automatically &amp;ldquo;the best&amp;rdquo; integrator for all applications (it’s not), or that you should always use this integrator over other methods listed above (you shouldn’t).&lt;/p&gt;

&lt;p&gt;But it is one of the most accurate general purpose integration techniques available. Read on for details on how to implement it.&lt;/p&gt;

&lt;h2 id=&#34;implementing-rk4-is-not-as-hard-as-it-looks&#34;&gt;Implementing RK4 is not as hard as it looks&lt;/h2&gt;

&lt;p&gt;I could present to you RK4 in form of general mathematical equations, but seeing as my target audience for this article are programmers, not mathematicians, I will explain using code instead.&lt;/p&gt;

&lt;p&gt;So before we go any further lets define the state of an object as a struct in C++ so that we have both position and velocity values conveniently stored in one place:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct State
    {
        float x;      // position
        float v;      // velocity
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need a struct to store the derivatives of the state values so we can easily pass them around:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct Derivative
    {
        float dx;      // dx/dt = velocity
        float dv;      // dv/dt = acceleration
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece of the puzzle that we need is a function to advance the physics state ahead from t to t+dt using one set of derivatives, and once there recalculate the derivatives at this new state.&lt;/p&gt;

&lt;p&gt;This routine is the heart of the RK4 integrator and it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Derivative evaluate( const State &amp;amp; initial, 
                         double t, 
                         float dt, 
                         const Derivative &amp;amp; d )
    {
        State state;
        state.x = initial.x + d.dx*dt;
        state.v = initial.v + d.dv*dt;

        Derivative output;
        output.dx = state.v;
        output.dv = acceleration( state, t+dt );
        return output;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s absolutely critical that you understand what this method is doing. First it takes the current state of the object (its position and velocity) and advances it ahead dt seconds using an Euler Integration step with the derivatives that were passed in (velocity and acceleration). Once this new position and velocity are calculated, it calculates new derivatives at this point in time using the integrated state.&lt;/p&gt;

&lt;p&gt;Most importantly, each of these derivatives will be &lt;em&gt;different&lt;/em&gt; from the derivatives at the start of the time step when the rate of change in these quantities changes as a function of time, or as a function of the object state itself. For example, a Hooke&amp;rsquo;s law spring force which is a function of the current position, or drag forces that are a function of the current velocity.&lt;/p&gt;

&lt;p&gt;The acceleration function is what drives the entire simulation and in the example source code for this article is defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    float acceleration( const State &amp;amp; state, double t )
    {
        const float k = 10;
        const float b = 1;
        return -k * state.x - b*state.v;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function calculates a spring and damper force and returns it as the acceleration assuming unit mass. What you write here of course is completely simulation dependent, but it is crucial that you structure your simulation in such a way that it can calculate the acceleration or force completely from inside this method given the current state and time, otherwise your simulation cannot work with the RK4 integrator.&lt;/p&gt;

&lt;p&gt;Finally we get to the integration routine itself which integrates the state ahead from t to t+dt using RK4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    void integrate( State &amp;amp; state, 
                    double t, 
                    float dt )
    {
        Derivative a,b,c,d;

        a = evaluate( state, t, 0.0f, Derivative() );
        b = evaluate( state, t, dt*0.5f, a );
        c = evaluate( state, t, dt*0.5f, b );
        d = evaluate( state, t, dt, c );

        float dxdt = 1.0f / 6.0f * 
            ( a.dx + 2.0f * ( b.dx + c.dx ) + d.dx );

        float dvdt = 1.0f / 6.0f * 
            ( a.dv + 2.0f * ( b.dv + c.dv ) + d.dv );

        state.x = state.x + dxdt * dt;
        state.v = state.v + dvdt * dt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the multiple calls to evaluate that make up this routine. RK4 samples derivatives four times to detect curvature instead of just once in Euler integration. The important thing to understand is how it actually does this sampling.&lt;/p&gt;

&lt;p&gt;If you look at the code above it should be clear what is going on. Notice how it uses the previous derivative when calculating the next one. When calculating derivative b it steps ahead from t to t+dt*0.5 using derivative a, then to calculate c it steps ahead using derivative b, and finally d is calculated by stepping ahead with c. This feedback of the current derivative into the calculation of the next one is what gives the RK4 integrator its accuracy.&lt;/p&gt;

&lt;p&gt;Once the four derivative samples have been evaluated, the best overall derivative is calculated using a weighted sum of the derivatives. These weights comes from the Taylor Series. This single derivative can then be used to advance the position and velocity over dt as we did before in the Euler integrator.&lt;/p&gt;

&lt;p&gt;Notice that even when using a complicated integrator such as RK4, it all boils down into something += rate of change * delta time. This is because differentiation and integration are fundamentally linear operations. For now we are just integrating single values, but rest assured it all ends up like this when integrating vectors or even quaternions for rotational dynamics.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;(todo: clean this up, this conclusion is poorly written)&lt;/p&gt;

&lt;p&gt;I have demonstrated how to implement an RK4 integrator for a basic physics simulation. At this point if you are serious about learning game physics you should study the example source code that comes with this article and play around with it.&lt;/p&gt;

&lt;p&gt;Here are some ideas for study:&lt;/p&gt;

&lt;p&gt;Switch from integrating velocity directly from acceleration to integrating momentum from force instead (the derivative of momentum is force). You will need to add “mass” and “inverseMass” to the State struct and I recommend adding a method called “recalculate” which updates velocity = momentum * inverseMass whenever it is called. Every time you modify the momentum value you need to recalculate the velocity. You should also rename the acceleration method to “force”. Why do this? Later on when working with rotational dynamics you will need to work with angular momentum directly instead of angular velocity, so you might as well start now.
Try modifying the integrate method to implement an Euler integrator. Compare the results of the simulation against the RK4 integrator. How much can you increase the spring constant k before the simulation explodes with Euler? How large can you make it with RK4?
Extend position, velocity and force to 3D quantities using vectors. If you use your intuition you should easily be able to extend the RK4 integrator to do this.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>