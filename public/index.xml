<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gaffer On Games</title>
    <link>http://173.255.195.190/gafferongames/index.xml</link>
    <description>Recent content on Gaffer On Games</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© The Network Protocol Company, Inc.</copyright>
    <lastBuildDate>Sun, 24 May 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://173.255.195.190/gafferongames/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>About</title>
      <link>http://173.255.195.190/gafferongames/about/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/about/</guid>
      <description>&lt;p&gt;Hi, I’m &lt;a href=&#34;https://www.linkedin.com/in/glennfiedler&#34;&gt;Glenn Fiedler&lt;/a&gt; the author of &lt;strong&gt;gafferongames.com&lt;/strong&gt;. I&amp;rsquo;m a professional network programmer with 15 years experience in the game industry.&lt;/p&gt;

&lt;p&gt;These days I run &lt;a href=&#34;http://www.thenetworkprotocolcompany.com&#34;&gt;The Network Protocol Company&lt;/a&gt; which is dedicated to helping people network their games by sharing information, consulting with teams, and of course, writing articles and open source code for this website.&lt;/p&gt;

&lt;p&gt;Before I started my own company I worked as a senior and lead programmer on many different areas of code. I started out as a graphics programmer in my first industry job way back in 1998, but very quickly became more interested in game physics and networking. In 2006 I specialized in game networking and moved to the United States. The rest, as they say, is history.&lt;/p&gt;

&lt;p&gt;During my career I’ve been fortunate enough to work on some great games:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/playstation-4/titanfall-2&#34;&gt;Titanfall 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/xbox-360/titanfall&#34;&gt;Titanfall&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/playstation-3/god-of-war-ascension&#34;&gt;God of War: Ascension&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/playstation-3/playstation-all-stars-battle-royale&#34;&gt;Playstation: All-Stars&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/playstation-3/journey&#34;&gt;Journey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/playstation-3/la-noire&#34;&gt;L.A. Noire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/playstation-3/god-of-war-iii&#34;&gt;God of War 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/xbox-360/mercenaries-2-world-in-flames&#34;&gt;Mercenaries 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/pc/tribes-vengeance&#34;&gt;Tribes: Vengeance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/pc/swat-4&#34;&gt;SWAT 4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.metacritic.com/game/pc/freedom-force&#34;&gt;Freedom Force&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And throughout all this I&amp;rsquo;ve always believed strongly in sharing information. Giving back. Writing articles and example source code so people encounting the same problems I did don&amp;rsquo;t have to learn everything through trial and error.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been writing articles for over 10 years now and people tell me all the time how much the articles have helped them. But writing articles and open source code is just so much work. I rely on donations to pay for hosting costs and to carve out time from consulting to write new articles and open source code.&lt;/p&gt;

&lt;p&gt;So if you enjoy the articles on this website, please support my work on &lt;a href=&#34;https://www.patreon.com/gafferongames&#34;&gt;Patreon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for your support!&lt;/p&gt;

&lt;p&gt;&amp;ndash; Glenn&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>http://173.255.195.190/gafferongames/contact/</link>
      <pubDate>Sun, 24 May 2015 18:52:04 +0200</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/contact/</guid>
      <description>&lt;p&gt;Want to get in touch with me? Fill out the form below to send me a message.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why can&#39;t I send UDP packets from a browser?</title>
      <link>http://173.255.195.190/gafferongames/post/why_cant_i_send_udp_packets_from_a_browser/</link>
      <pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/why_cant_i_send_udp_packets_from_a_browser/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;Your title in the form of a reader&amp;rsquo;s problem / solution&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Client Server Connection</title>
      <link>http://173.255.195.190/gafferongames/post/client_server_connection/</link>
      <pubDate>Wed, 28 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/client_server_connection/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m &lt;a href=&#34;http://173.255.195.190/gafferongames/about&#34;&gt;Glenn Fiedler&lt;/a&gt; and welcome to &lt;strong&gt;&lt;a href=&#34;http://173.255.195.190/gafferongames/categories/building-a-game-network-protocol/&#34;&gt;Building a Game Network Protocol&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In this article we&amp;rsquo;re going to build a client/server connection on top of UDP.&lt;/p&gt;

&lt;p&gt;And I can almost guarantee you at this point that some people have decided not to read this article because I&amp;rsquo;m obviously a fool. I mean, who could possibly justify all the effort required to build a completely custom client/server network protocol on top of UDP, when, for so many people, TCP is simply good enough? Check out this clown! Obviously you should just use TCP, or &lt;em&gt;(insert some other protocol that happens to be built on top of UDP anyway)&lt;/em&gt;. Sigh.&lt;/p&gt;

&lt;p&gt;Why is it in 2016 that discussions about UDP vs. TCP are still so controversial, why is it that pages of uninformed comments spring up on Hacker News with each post I make about UDP-based protocols, posts written about the best practices I&amp;rsquo;ve learned over 10 years working in the game industry as a network programmer? I&amp;rsquo;m not mad, just frustrated, and honestly kind of perplexed! Why does this topic bring out such strong reactions in people?&lt;/p&gt;

&lt;p&gt;And why is this even a point for discussion, when it&amp;rsquo;s been a solved problem in the game industry for at least 20 years, when most fast paced games, and virtually &lt;em&gt;all&lt;/em&gt; first person shooters are networked using UDP?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Counterstrike&lt;/li&gt;
&lt;li&gt;Call of Duty&lt;/li&gt;
&lt;li&gt;Titanfall&lt;/li&gt;
&lt;li&gt;Halo&lt;/li&gt;
&lt;li&gt;Battlefield&lt;/li&gt;
&lt;li&gt;Overwatch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these games. Every. Single. One. Is networked with a custom client/server network protocol built on top of UDP. This is the established best practice in the industry because it gets the best result. If you&amp;rsquo;re making a first person shooter and you&amp;rsquo;re networking it with TCP, you&amp;rsquo;re making a mistake. Simple as that.&lt;/p&gt;

&lt;p&gt;So while TCP is useful in many contexts, in the context of fast paced action games played over the internet, it&amp;rsquo;s all UDP, baby. Before we get down to the gritty details of implementing one of these protocols, let&amp;rsquo;s spend a bit of time exploring why this is.&lt;/p&gt;

&lt;h2 id=&#34;why-first-person-shooters-use-udp&#34;&gt;Why First Person Shooters Use UDP&lt;/h2&gt;

&lt;p&gt;First person shooters are different to web servers&lt;a href=&#34;#quic_footnote&#34;&gt;*&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First person shooters send &lt;strong&gt;time critical data&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Data like player inputs sent from client to server, or the state of the world sent from server to client. If this data arrives late, it is &lt;em&gt;utterly useless&lt;/em&gt; and is thrown away. The client has no use for the state of the world &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; of a second ago, just like the server has no use for player input from the past.&lt;/p&gt;

&lt;p&gt;So, why can&amp;rsquo;t we use TCP for time critical data? The answer is that TCP delivers data reliably and in-order, and to do this on top of IP, which is unreliable and unordered, it holds more recent packets &lt;em&gt;(that we want)&lt;/em&gt; hostage in a queue while older packets &lt;em&gt;(that we don&amp;rsquo;t!)&lt;/em&gt; are resent over the network.&lt;/p&gt;

&lt;p&gt;This is known as &lt;strong&gt;head of line blocking&lt;/strong&gt; and it&amp;rsquo;s a &lt;em&gt;huuuuuge&lt;/em&gt; problem for time critical data. To understand why, consider a game server broadcasting the state of the world to clients 10 times per-second. Each client advances time forward and wants to display the most recent state it has received from the server.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/client-time.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;But if the packet containing state for time t = 10.0 is lost, under TCP we must wait for it to be resent before we can access t = 10.1 and 10.2, even though those packets have already arrived and contain the state the client wants to show. Worse still, by the time the resent packet arrives, it&amp;rsquo;s far too late for the client to actually do anything useful with it. The client has already advanced past 10.0 and wants to display something around 10.3 or 10.4!&lt;/p&gt;

&lt;p&gt;So why resend dropped packets at all? &lt;strong&gt;BINGO!&lt;/strong&gt; What we&amp;rsquo;d really like is an option to tell TCP: &amp;ldquo;Hey, I don&amp;rsquo;t care about old packets being resent, by they time they arrive I can&amp;rsquo;t use them anyway, so just let me skip over them and access the most recent data&amp;rdquo;. But TCP simply does not give us this option. All data must be delivered reliably and in-order.&lt;/p&gt;

&lt;p&gt;This creates terrible problems for time critical data where packet loss &lt;em&gt;and&lt;/em&gt; latency exist. Situations like, you know, The Internet, where people play FPS games. Large hitches corresponding to multiples of round trip time are added to the stream of data as TCP waits for dropped packets to be resent, which means additional buffering to smooth out these hitches, or long pauses where the game freezes and is non-responsive.&lt;/p&gt;

&lt;p&gt;Neither option is acceptable for first person shooters, which is why virtually all first person shooters are networked using UDP. UDP doesn&amp;rsquo;t provide any reliability or ordering, so protocols built on top of UDP can access the most recent data without waiting for lost packets to be resent, implementing whatever reliability they need in radically different ways to TCP.&lt;/p&gt;

&lt;p&gt;But, using UDP comes at a cost:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP doesn&amp;rsquo;t provide any concept of connection.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We have to build that ourselves. This is a lot of work! So strap in, get ready, because we&amp;rsquo;re going to build it all up from scratch using the same basic techniques first person shooters use when creating their protocols over UDP. I know, I&amp;rsquo;ve worked on a few. You can use this client/server protocol for games or non-gaming applications and, provided the data you send is time critical, I promise you, it&amp;rsquo;s well worth the effort.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;quic_footnote&#34;&gt;&lt;/a&gt; &lt;em&gt;* These days even web servers are transitioning to UDP via &lt;a href=&#34;https://ma.ttias.be/googles-quic-protocol-moving-web-tcp-udp/&#34;&gt;Google&amp;rsquo;s QUIC&lt;/a&gt;. If you still think TCP is good enough for time critical data in 2016, I encourage you to put that in your pipe and smoke it :)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;what-we-re-building&#34;&gt;What We&amp;rsquo;re Building&lt;/h2&gt;

&lt;p&gt;The goal is to create an abstraction on top of a UDP socket where our server presents a number of &lt;em&gt;virtual slots&lt;/em&gt; for clients to connect to:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/connection-request.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;When a client requests a connection, it gets assigned to one of these slots:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/connection-accepted.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;If a client requests connection, but no slots are available, the server is full and the connection request is denied:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/server-is-full.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Once a client is connected, packets are exchanged in both directions. These packets form the basis for the custom protocol between the client and server which is game specific.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/client-server-packets.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;In a first person shooter, packets are sent continuously in both directions. Clients send input to the server as quickly as possible, often 30 or 60 times per-second, and the server broadcasts the state of the world to clients 10, 20 or even 60 times per-second.&lt;/p&gt;

&lt;p&gt;Because of this steady flow of packets in both directions there is no need for keep-alive packets. If at any point packets stop being received from the other side, the connection simply times out. No packets for 5 seconds is a good timeout value in my opinion, but you can be more aggressive if you want.&lt;/p&gt;

&lt;p&gt;When a client slot times out on the server, it becomes available for other clients to connect. When the client times out, it transitions to an error state.&lt;/p&gt;

&lt;h2 id=&#34;simple-connection-protocol&#34;&gt;Simple Connection Protocol&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started with the implementation of a simple protocol. It&amp;rsquo;s a bit basic and more than a bit naive, but it&amp;rsquo;s a good starting point and we&amp;rsquo;ll build on it during the rest of this article, and the next few articles in this series.&lt;/p&gt;

&lt;p&gt;First up we have the client state machine.&lt;/p&gt;

&lt;p&gt;The client is in one of three states:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Disconnected&lt;/li&gt;
&lt;li&gt;Connecting&lt;/li&gt;
&lt;li&gt;Connected&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Initially the client starts in &lt;strong&gt;disconnected&lt;/strong&gt;, and is told to connect to a server with a particular IP address and port. At this point the client transitions to the &lt;strong&gt;connecting&lt;/strong&gt; state and sends &lt;u&gt;&lt;em&gt;connection request&lt;/em&gt;&lt;/u&gt; packets to the server.&lt;/p&gt;

&lt;p&gt;They look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/connection-request-packet.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The CRC32 and implicit protocol id in the packet header allow the server to trivially reject UDP packets not belonging to this protocol or from a different version of it. For details, please see &lt;a href=&#34;http://gafferongames.com/building-a-game-network-protocol/reading-and-writing-packets/&#34;&gt;Reading and Writing Packets&lt;/a&gt; and &lt;a href=&#34;http://gafferongames.com/building-a-game-network-protocol/serialization-strategies/&#34;&gt;Serialization Strategies&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since connection request packets are sent over UDP, they may be lost, received in duplicate, or out of order. Because of this we do two things: 1) we keep sending packets for the client state until we get a response from the server, or the client times out, and 2) on both client and server we ignore any packets that don&amp;rsquo;t correspond to what we are expecting, since a lot of redundant packets are flying over the network.&lt;/p&gt;

&lt;p&gt;On the server, we have the following data structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    const int MaxClients = 64;

    class Server
    {
        int m_maxClients;
        int m_numConnectedClients;
        bool m_clientConnected[MaxClients];
        Address m_clientAddress[MaxClients];
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which lets the server lookup a free slot for a client to join (if any are free):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int Server::FindFreeClientIndex() const
    {
        for ( int i = 0; i &amp;lt; m_maxClients; ++i )
        {
            if ( !m_clientConnected[i] )
                return i;
        }
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the client index corresponding to an IP address and port:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int Server::FindExistingClientIndex( const Address &amp;amp; address ) const
    {
        for ( int i = 0; i &amp;lt; m_maxClients; ++i )
        {
            if ( m_clientConnected[i] &amp;amp;&amp;amp; m_clientAddress[i] == address )
                return i;
        }
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check if a client is connected to a given slot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool Server::IsClientConnected( int clientIndex ) const
    {
        return m_clientConnected[clientIndex];
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and retrieve a client’s IP address and port by client index:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    const Address &amp;amp; Server::GetClientAddress( int clientIndex ) const
    {
        return m_clientAddress[clientIndex];
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using these queries we can implement the following logic when a &lt;u&gt;&lt;em&gt;connection request&lt;/em&gt;&lt;/u&gt; packet is received on the server:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If the server is full, reply with &lt;u&gt;&lt;em&gt;connection denied: server is full&lt;/em&gt;&lt;/u&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the sender corresponds to the address of a client that is already connected, reply with &lt;u&gt;&lt;em&gt;connection accepted&lt;/em&gt;&lt;/u&gt;. This is necessary because the first response may not have gotten through. If we don&amp;rsquo;t resend this response, the client gets stuck in the &lt;strong&gt;connecting&lt;/strong&gt; state until it times out.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise, this connection request is from a new client and we have a slot free. Assign the client to the free slot and respond with &lt;u&gt;&lt;em&gt;connection accepted&lt;/em&gt;&lt;/u&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The connection accepted packet tells the client which client index it was assigned, which the client needs to know which player it is in the game:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/connection-accepted-packet.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Once the server sends a connection accepted packet, from its point of view it considers that client connected. As the server ticks forward, it watches connected client slots, and if no packets have been received from that client for 5 seconds, the slot times out and is reset, ready for another client to connect.&lt;/p&gt;

&lt;p&gt;Back on the client, while in the &lt;strong&gt;connecting&lt;/strong&gt; state the client listens for &lt;u&gt;&lt;em&gt;connection denied&lt;/em&gt;&lt;/u&gt; and &lt;u&gt;&lt;em&gt;connection accepted&lt;/em&gt;&lt;/u&gt; packets from the server. Any other packets are ignored. If the client receives &lt;u&gt;&lt;em&gt;connection accepted&lt;/em&gt;&lt;/u&gt;, it transitions to &lt;strong&gt;connected&lt;/strong&gt;. If it receives &lt;u&gt;&lt;em&gt;connection denied&lt;/em&gt;&lt;/u&gt;, or after 5 seconds hasn&amp;rsquo;t received any response from the server, it transitions to &lt;strong&gt;disconnected&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Once the client hits &lt;strong&gt;connected&lt;/strong&gt; it starts sending connection payload packets to the server. If no packets are received from the server in 5 seconds, the client times out and transitions to &lt;strong&gt;disconnected&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;weaknesses-of-the-simple-connection-protocol&#34;&gt;Weaknesses of the Simple Connection Protocol&lt;/h2&gt;

&lt;p&gt;While this protocol is easy to implement, we can&amp;rsquo;t use a protocol like this in production. It&amp;rsquo;s way too naive. It simply has too many weaknesses to be taken seriously:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Spoofed packet source addresses can be used to redirect connection accepted responses to a target (victim) address. If the connection accepted packet is larger than the connection request packet, attackers can use this protocol as part of a &lt;a href=&#34;https://www.us-cert.gov/ncas/alerts/TA14-017A&#34;&gt;DDoS amplification attack&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spoofed packet source addresses can be used to trivially fill all client slots on a server by sending connection request packets from n different IP addresses, where n is the number of clients allowed per-server. This is a real problem for dedicated servers. Obviously you want to make sure that only real clients are filling slots on servers you are paying for.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An attacker can trivially fill all slots on a server by varying the client UDP port number on each client connection. This is because clients are considered unique on an address + port basis. This isn&amp;rsquo;t easy to fix because due to NAT (network address translation), different players behind the same router collapse to the same IP address with only the port being different.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Traffic between the client and server can be read and modified in transit by a third party. While the CRC32 protects against packet corruption, an attacker would simply recalculate the CRC32 to match the modified packet.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If an attacker knows the client and server IP addresses and ports, they can impersonate the client or server. This gives an attacker the power to completely a hijack a client’s connection and perform actions on their behalf.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once a client is connected to a server there is no way for them to disconnect cleanly, they can only time out. This creates a delay before the server realizes a client has disconnected, or before a client realizes the server has shut down. It would be nice if both the client and server could indicate a clean disconnect, so the other side doesn’t need to wait for timeout in the common case.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clean disconnection is usually implemented with a disconnect packet, however because an attacker can impersonate the client and server with spoofed packets, doing so would give the attacker the ability to disconnect a client from the server whenever they like, provided they know the client and server IP addresses and the structure of the disconnect packet.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a client disconnects dirty and attempts to reconnect before their slot times out on the server, the server still thinks that client is connected and replies with &lt;u&gt;&lt;em&gt;connection accepted&lt;/em&gt;&lt;/u&gt; to handle packet loss. The client processes this response and thinks it&amp;rsquo;s connected to the server, but it&amp;rsquo;s actually in an undefined state.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While some of these problems require authentication and encryption before they can be fully solved, we can make some small steps forward to improve the protocol before we get to that. These changes are instructive.&lt;/p&gt;

&lt;h2 id=&#34;improving-the-connection-protocol&#34;&gt;Improving The Connection Protocol&lt;/h2&gt;

&lt;p&gt;The first thing we want to do is only allow clients to connect if they can prove they are actually at the IP address and port they say they are.&lt;/p&gt;

&lt;p&gt;To do this, we no longer accept client connections immediately on connection request, instead we send back a challenge packet, and only complete connection when a client replies with information that can only be obtained from that challenge packet.&lt;/p&gt;

&lt;p&gt;The sequence of operations in a typical connect now looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/challenge-response.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;To implement this we need an additional data structure on the server. Somewhere to store the challenge data for pending connections, so when a challenge response comes in from a client we can check against the corresponding entry in the data structure and make sure it&amp;rsquo;s a valid response to the challenge sent to that address.&lt;/p&gt;

&lt;p&gt;While the pending connect data structure can be made larger than the maximum number of connected clients, it&amp;rsquo;s still ultimately finite and is therefore subject to attack. We&amp;rsquo;ll cover some defenses against this in the next article. But for the moment, be happy at least that attackers can&amp;rsquo;t progress to the &lt;strong&gt;connected&lt;/strong&gt; state with spoofed packet source addresses.&lt;/p&gt;

&lt;p&gt;Next, to guard against our protocol being used in a DDoS amplification attack, we&amp;rsquo;ll inflate client to server packets so they&amp;rsquo;re large relative to the response packet sent from the server. This means we add padding to both &lt;u&gt;&lt;em&gt;connection request&lt;/em&gt;&lt;/u&gt; and &lt;u&gt;&lt;em&gt;challenge response&lt;/em&gt;&lt;/u&gt; packets and enforce this padding on the server, ignoring any packets without it. Now our protocol effectively has DDoS &lt;em&gt;minification&lt;/em&gt; for requests -&amp;gt; responses, making it highly unattractive for anyone thinking of launching this kind of attack.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll do one last small thing to improve the robustness and security of the protocol. It&amp;rsquo;s not perfect, we need authentication and encryption for that, but it at least it ups the ante, requiring attackers to actually sniff traffic in order to impersonate the client or server. We&amp;rsquo;ll add some unique random identifiers, or &amp;lsquo;salts&amp;rsquo;, to make each client connection unique from previous ones coming from the same IP address and port.&lt;/p&gt;

&lt;p&gt;The connection request packet now looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/connection-request-packet-2.0.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The client salt in the packet is a random 64 bit integer rolled each time the client starts a new connect. Connection requests are now uniquely identified by the IP address and port combined with this client salt value. This distinguishes packets from the current connection from any packets belonging to a previous connection, which makes connection and reconnection to the server much more robust.&lt;/p&gt;

&lt;p&gt;Now when a connection request arrives and a pending connection entry can&amp;rsquo;t be found in the data structure (according to IP, port and client salt) the server rolls a server salt and stores it with the rest of the data for the pending connection before sending a challange packet back to the client. If a pending connection is found, the salt value stored in the data structure is used for the challenge. This way there is always a consistent pair of client and server salt values corresponding to each client session.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/challenge-packet.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The client state machine has been expanded so &lt;strong&gt;connecting&lt;/strong&gt; is replaced with two new states: &lt;strong&gt;sending connection request&lt;/strong&gt; and &lt;strong&gt;sending challenge response&lt;/strong&gt;, but it&amp;rsquo;s the same idea as before. Client states repeatedly send the packet corresponding to that state to the server while listening for the response that moves it forward to the next state, or back to an error state. If no response is received, the client times out and transitions to &lt;strong&gt;disconnected&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The challenge response sent from the client to the server looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/challenge-response-packet.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The utility of this being that once the client and server have established connection, we prefix all payload packets with the xor of the client and server salt values and discard any packets with the incorrect salt values. This neatly filters out packets from previous sessions and requires an attacker to sniff packets in order to impersonate a client or server.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/connection-payload-packet.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Now that we have at least a &lt;em&gt;basic&lt;/em&gt; level of security, it&amp;rsquo;s not much, but at least it&amp;rsquo;s &lt;strong&gt;something&lt;/strong&gt;, we can implement a disconnect packet:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/network-protocol/disconnect-packet.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;And when the client or server want to disconnect clean, they simply fire 10 of these over the network to the other side, in the hope that some of them get through, and the other side disconnects cleanly instead of waiting for timeout.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve discussed why first person shooters use UDP instead of TCP and created a simple client/server connection protocol on top of UDP based around the concept of client slots.&lt;/p&gt;

&lt;p&gt;We explored the downsides of an inital naive implementation and hardened it against DDoS amplification and spoofed packet source addresses. We extended the protocol with client sessions using salt values, so packets from previous sessions are filtered out and attackers must sniff traffic to impersonate the client or server. We also added disconnect packets so clean disconnection doesn&amp;rsquo;t have to wait for timeout.&lt;/p&gt;

&lt;p&gt;But we&amp;rsquo;re far from done. The protocol is greatly improved but it&amp;rsquo;s still only one I would consider suitable for a LAN game played in your office. Hostile actors can still sniff traffic and impersonate a client or server, read the contents of your packets, modify them in transit, and spin up zombie clients to consume your dedicated server resources.&lt;/p&gt;

&lt;p&gt;Stay tuned for the next article: &lt;strong&gt;Securing Dedicated Servers&lt;/strong&gt; where I describe the best practices for securing your client/server UDP protocol, incorporating authentication, encryption and signing so only &lt;em&gt;real&lt;/em&gt; clients can connect to your dedicated server, your game traffic can&amp;rsquo;t be read or modified in transit, and it&amp;rsquo;s no longer possible to impersonate a client or server.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Snapshot Compression</title>
      <link>http://173.255.195.190/gafferongames/post/snapshot_compression/</link>
      <pubDate>Sun, 04 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/snapshot_compression/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m &lt;a href=&#34;http://173.255.195.190/gafferongames/about&#34;&gt;Glenn Fiedler&lt;/a&gt; and welcome to &lt;strong&gt;&lt;a href=&#34;http://173.255.195.190/gafferongames/categories/networked-physics/&#34;&gt;Networked Physics&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://gafferongames.com/networked-physics/snapshots-and-interpolation/&#34;&gt;previous article&lt;/a&gt; we sent snapshots of the entire simulation 10 times per-second over the network and interpolated between them to reconstruct a view of the simulation on the other side.&lt;/p&gt;

&lt;p&gt;The problem with a low snapshot rate is that interpolation between snapshots adds interpolation delay on top of network latency. At 10 snapshots per-second, the minimum interpolation delay is 100ms, and a more practical minimum considering network jitter is 150ms. If protection against one or two lost packets in a row is desired, this blows out to 250ms or 350ms.&lt;/p&gt;

&lt;p&gt;This is not an acceptable amount of delay for most games, but when the physics simulation is as unpredictable as ours, the only way to reduce it is to increase the packet send rate. Unfortunately, increasing the send rate also increases bandwidth. So what we&amp;rsquo;re going to do in this article is work through every possible bandwidth optimization &lt;em&gt;(that I can think of at least)&lt;/em&gt; until we get bandwidth under control.&lt;/p&gt;

&lt;p&gt;Our target bandwidth is &lt;strong&gt;&lt;u&gt;256 kilobits per-second&lt;/u&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;starting-point-60hz&#34;&gt;Starting Point @ 60HZ&lt;/h1&gt;

&lt;p&gt;Life is rarely easy, and the life of a network programmer, even less so. As network programmers we&amp;rsquo;re often tasked with the impossible, so in that spirit, let&amp;rsquo;s increase the snapshot send rate from 10 to 60 snapshots per-second and see exactly how far away we are from our target bandwidth.&lt;/p&gt;

&lt;video preload=&#34;auto&#34; controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_compression_uncompressed.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_compression_uncompressed.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;o_O&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a &lt;em&gt;LOT&lt;/em&gt; of bandwidth: &lt;strong&gt;&lt;u&gt;17.37 megabits per-second!&lt;/u&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s break it down and see where all the bandwidth is going.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the state sent per-cube in the snapshot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct CubeState
    {
        bool interacting;
        vec3f position;
        vec3f linear_velocity;
        quat4f orientation;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the size of each field sent over the network, uncompressed:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;quat orientation: &lt;b&gt;128 bits&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;vec3 linear_velocity: &lt;b&gt;96 bits&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;vec3 position: &lt;b&gt;96 bits&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;bool interacting: &lt;b&gt;1 bit&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This gives a total of 321 bits bits per-cube (or 40.125 bytes per-cube).&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do a quick calculation to see if the bandwidth checks out. The scene has 901 cubes so &lt;strong&gt;901*40.125 = 36152.625&lt;/strong&gt; bytes of cube data per-snapshot. 60 snapshots per-second so &lt;strong&gt;36152.625 * 60 = 2169157.5&lt;/strong&gt; bytes per-second. Add in packet header estimate: &lt;strong&gt;2169157.5 + 32*60 = 2170957.5&lt;/strong&gt;. Convert bytes per-second to megabits per-second: &lt;strong&gt;2170957.5 * 8 / ( 1000 * 1000 ) = 17.38mbps&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Everything checks out. There&amp;rsquo;s no easy way around this, we&amp;rsquo;re sending a hell of a lot of bandwidth, and we have to reduce that to something around 1-2% of it&amp;rsquo;s current bandwidth to hit our target of 256 kilobits per-second.&lt;/p&gt;

&lt;p&gt;Is this even possible? &lt;em&gt;Of course it is!&lt;/em&gt; Let&amp;rsquo;s get started :)&lt;/p&gt;

&lt;h2 id=&#34;optimizing-orientation&#34;&gt;Optimizing Orientation&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll start by optimizing orientation because it&amp;rsquo;s the largest field. (When optimizing bandwidth it&amp;rsquo;s good to work in the order of greatest to least potential gain where possible&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Many people when compressing a quaternion think: &amp;ldquo;I know. I&amp;rsquo;ll just pack it into 8.8.8.8 with one 8 bit signed integer per-component!&amp;rdquo;. Sure, that works, but with a bit of math you can get much better accuracy with fewer bits using a trick called the &amp;ldquo;smallest three&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;How does the smallest three work? Since we know the quaternion represents a rotation its length must be 1, so x^2+y^2+z^2+w^2 = 1. We can use this identity to drop one component and reconstruct it on the other side. For example, if you send x,y,z you can reconstruct w = sqrt( 1 - x^2 - y^2 - z^2 ). You might think you need to send a sign bit for w in case it is negative, but you don&amp;rsquo;t, because you can make w always positive by negating the entire quaternion if w is negative (in quaternion space (x,y,z,w) and (-x,-y,-z,-w) represent the same rotation.)&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t always drop the same component due to numerical precision issues. Instead, find the component with the largest absolute value and encode its index using two bits [0,3] (0=x, 1=y, 2=z, 3=w), then send the index of the largest component and the smallest three components over the network (hence the name). On the other side use the index of the largest bit to know which component you have to reconstruct from the other three.&lt;/p&gt;

&lt;p&gt;One final improvement. If v is the absolute value of the largest quaternion component, the next largest possible component value occurs when two components have the same absolute value and the other two components are zero. The length of that quaternion (v,v,0,0) is 1, therefore v^2 + v^2 = 1, 2v^2 = 1, v = 1/sqrt(2). This means you can encode the smallest three components in [-0.707107,+0.707107] instead of [-1,+1] giving you more precision with the same number of bits.&lt;/p&gt;

&lt;p&gt;With this technique I&amp;rsquo;ve found that minimum sufficient precision for my simulation is 9 bits per-smallest component. This gives a result of 2 + 9 + 9 + 9 = 29 bits per-orientation (down from 128 bits).&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_orientation.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_orientation.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;This optimization reduces bandwidth by over 5 megabits per-second, and I think if you look at the right side, you&amp;rsquo;d be hard pressed to spot any artifacts from the compression.&lt;/p&gt;

&lt;h2 id=&#34;optimizing-linear-velocity&#34;&gt;Optimizing Linear Velocity&lt;/h2&gt;

&lt;p&gt;What should we optimize next? It&amp;rsquo;s a tie between linear velocity and position. Both are 96 bits. In my experience position is the harder quantity to compress so let&amp;rsquo;s start with linear velocity.&lt;/p&gt;

&lt;p&gt;To compress linear velocity we need to bound its x,y,z components in some range so we don&amp;rsquo;t need to send full float values. I found that a maximum speed of 32 meters per-second is a nice power of two and doesn&amp;rsquo;t negatively affect the player experience in the cube simulation. Since we&amp;rsquo;re really only using the linear velocity as a &lt;em&gt;hint&lt;/em&gt; to improve interpolation between position sample points we can be pretty rough with compression. 32 distinct values per-meter per-second provides acceptable precision.&lt;/p&gt;

&lt;p&gt;Linear velocity has been bounded and quantized and is now three integers in the range [-1024,1023]. That breaks down as follows: [-32,+31] (6 bits) for integer component and multiply 5 bits fraction precision. I hate messing around with sign bits so I just add 1024 to get the value in range [0,2047] and send that instead. To decode on receive just subtract 1024 to get back to signed integer range before converting to float.&lt;/p&gt;

&lt;p&gt;11 bits per-component gives 33 bits total per-linear velocity. Just over &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; the original uncompressed size!&lt;/p&gt;

&lt;p&gt;We can do even better than this because most cubes are stationary. To take advantage of this we just write a single bit &amp;ldquo;at rest&amp;rdquo;. If this bit is 1, then velocity is known zero and is not sent. Otherwise, the compressed velocity follows after the bit (33 bits). Cubes at rest now cost just 127 bits, while cubes that are moving cost one bit more than they previously did: 159 + 1 = 160 bits.&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_at_rest_flag.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_at_rest_flag.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;But why are we sending linear velocity at all? In the &lt;a href=&#34;http://gafferongames.com/networked-physics/snapshots-and-interpolation/&#34;&gt;previous article&lt;/a&gt; we decided to send it because it improved the quality of interpolation at 10 snapshots per-second, but now that we&amp;rsquo;re sending 60 snapshots per-second is this still necessary? As you can see below the answer is &lt;em&gt;no&lt;/em&gt;.&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_no_velocity.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_no_velocity.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;Linear interpolation is good enough at 60HZ. This means we can avoid sending linear velocity entirely. Sometimes the best bandwidth optimizations aren&amp;rsquo;t about optimizing what you send, they&amp;rsquo;re about what you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; send.&lt;/p&gt;

&lt;h2 id=&#34;optimizing-position&#34;&gt;Optimizing Position&lt;/h2&gt;

&lt;p&gt;Now we have only position to compress. We&amp;rsquo;ll use the same trick we used for linear velocity: bound and quantize. I chose a position bound of [-256,255] meters in the horizontal plane (xy) and since in the cube simulation the floor is at z=0, I chose a range of [0,32] meters for z.&lt;/p&gt;

&lt;p&gt;Now we need to work out how much precision is required. With experimentation I found that 512 values per-meter (roughly 2mm precision) provides enough precision. This gives position x and y components in [-131072,+131071] and z components in range [0,16383]. That&amp;rsquo;s 18 bits for x, 18 bits for y and 14 bits for z giving a total of 50 bits per-position (originally 96).&lt;/p&gt;

&lt;p&gt;This reduces our cube state to 80 bits, or just 10 bytes per-cube.&lt;/p&gt;

&lt;p&gt;This is approximately &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; of the original cost. Definite progress!&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compressed_position.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compressed_position.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;Now that we&amp;rsquo;ve compressed position and orientation we&amp;rsquo;ve run out of simple optimizations. Any further reduction in precision results in unacceptable artifacts.&lt;/p&gt;

&lt;h2 id=&#34;delta-compression&#34;&gt;Delta Compression&lt;/h2&gt;

&lt;p&gt;Can we optimize further? The answer is yes, but only if we embrace a completely new technique: &lt;b&gt;&lt;u&gt;delta compression&lt;/u&gt;&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;Delta compression sounds mysterious. Magical. Hard. Actually, it&amp;rsquo;s not hard at all. Here&amp;rsquo;s how it works: the left side sends packets to the right like this: &amp;ldquo;This is snapshot 110 encoded relative to snapshot 100&amp;rdquo;. The snapshot being encoded relative to is called the baseline. How you do this encoding is up to you, there are many fancy tricks, but the basic, big order of magnitude win comes when you say: &amp;ldquo;Cube n in snapshot 110 is the same as the baseline. One bit: Not changed!&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;To implement delta encoding it is of course essential that the sender only encodes snapshots relative to baselines that the other side has received, otherwise they cannot decode the snapshot. Therefore, to handle packet loss the receiver has to continually send &amp;ldquo;ack&amp;rdquo; packets back to the sender saying: &amp;ldquo;the most recent snapshot I have received is snapshot n&amp;rdquo;. The sender takes this most recent ack and if it is more recent than the previous ack updates the baseline snapshot to this value. The next time a packet is sent out the snapshot is encoded relative to this more recent baseline. This process happens continuously such that the steady state becomes the sender encoding snapshots relative to a baseline that is roughly RTT (round trip time) in the past.&lt;/p&gt;

&lt;p&gt;There is one slight wrinkle: for one round trip time past initial connection the sender doesn&amp;rsquo;t have any baseline to encode against because it hasn&amp;rsquo;t received an ack from the receiver yet. I handle this by adding a single flag to the packet that says: &amp;ldquo;this snapshot is encoded relative to the initial state of the simulation&amp;rdquo; which is known on both sides. Another option if the receiver doesn&amp;rsquo;t know the initial state is to send down the initial state using a non-delta encoded path, eg. as one large data block, and once that data block has been received delta encoded snapshots are sent first relative to the initial baseline in the data block, then eventually converge to the steady state of baselines at RTT.&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_delta_not_changed.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_delta_not_changed.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;As you can see above this is a big win. We can refine this approach and lock in more gains but we&amp;rsquo;re not going to get another order of magnitude improvement like this past this point. From now on we&amp;rsquo;re going to have to work pretty hard to get a number of small, cumulative gains to reach our goal of 256 kilobits per-second.&lt;/p&gt;

&lt;h2 id=&#34;incremental-improvements&#34;&gt;Incremental Improvements&lt;/h2&gt;

&lt;p&gt;First small improvement. Each cube that isn&amp;rsquo;t sent costs 1 bit (not changed). There are 901 cubes so we send 901 bits in each packet even if no cubes have changed. At 60 packets per-second this adds up to 54kbps of bandwidth. Seeing as there are usually significantly less than 901 changed cubes per-snapshot in the common case, we can reduce bandwidth by sending only changed cubes with a cube index [0,900] identifying which cube it is. To do this we need to add a 10 bit index per-cube to identify it.&lt;/p&gt;

&lt;p&gt;There is a cross-over point where it is actually more expensive to send indices than not-changed bits. With 10 bit indices, the cost of indexing is 10*n bits. Therefore it&amp;rsquo;s more efficient to use indices if we are sending 90 cubes or less (900 bits). We can evaluate this per-snapshot and send a single bit in the header indicating which encoding we are using: 0 = indexing, 1 = changed bits. This way we can use the most efficient encoding for the number of changed cubes in the snapshot.&lt;/p&gt;

&lt;p&gt;This reduces the steady state bandwidth when all objects are stationary to around 15 kilobits per-second. This bandwidth is composed entirely of our own packet header (uint16 sequence, uint16 base, bool initial) plus IP and UDP headers (28 bytes).&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_delta_relative_index.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_delta_relative_index.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;Next small gain. What if we encoded the cube index relative to the previous cube index? Since we are iterating across and sending changed cube indices in-order: cube 0, cube 10, cube 11, 50, 52, 55 and so on we could easily encode the 2nd and remaining cube indices relative to the previous changed index, e.g.: +10, +1, +39, +2, +3. If we are smart about how we encode this index offset we should be able to, on average, represent a cube index with less than 10 bits.&lt;/p&gt;

&lt;p&gt;The best encoding depends on the set of objects you interact with. If you spend a lot of time moving horizontally while blowing cubes from the initial cube grid then you hit lots of +1s. If you move vertically from initial state you hit lots of +30s (sqrt(900)). What we need then is a general purpose encoding capable of representing statistically common index offsets with less bits.&lt;/p&gt;

&lt;p&gt;After a small amount of experimentation I came up with this simple encoding:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;[1,8] =&amp;gt; 1 + 3 (4 bits)&lt;/li&gt;
    &lt;li&gt;[9,40] =&amp;gt; 1 + 1 + 5 (7 bits)&lt;/li&gt;
    &lt;li&gt;[41,900] =&amp;gt; 1 + 1 + 10 (12 bits)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Notice how large relative offsets are actually more expensive than 10 bits. It&amp;rsquo;s a statistical game. The bet is that we&amp;rsquo;re going to get a much larger number of small offsets so that the win there cancels out the increased cost of large offsets. It works. With this encoding I was able to get an average of 5.5 bits per-relative index.&lt;/p&gt;

&lt;p&gt;Now we have a slight problem. We can no longer easily determine whether changed bits or relative indices are the best encoding. The solution I used is to run through a mock encoding of all changed cubes on packet write and count the number of bits required to encode relative indices. If the number of bits required is larger than 901, fallback to changed bits.&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_delta_relative_index.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_delta_relative_index.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;Next small improvement. Encoding position relative to (offset from) the baseline position. Here there are a lot of different options. You can just do the obvious thing, eg. 1 bit relative position, and then say 8-10 bits per-component if all components have deltas within the range provided by those bits, otherwise send the absolute position (50 bits).&lt;/p&gt;

&lt;p&gt;This gives a decent encoding but we can do better. If you think about it then there will be situations where one position component is large but the others are small. It would be nice if we could take advantage of this and send these small components using less bits.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a statistical game and the best selection of small and large ranges per-component depend on the data set. I couldn&amp;rsquo;t really tell looking at a noisy bandwidth meter if I was making any gains so I captured the position vs. position base data set and wrote it to a text file for analysis. The format is x,y,z,base_x,base_y,base_z with one cube per-line. The goal is to encode x,y,z relative to base x,y,z for each line. If you are interested, you can download this data set &lt;a href=&#34;http://gafferongames.com/wp-content/uploads/2015/02/position_values.txt&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I wrote a short ruby script to find the best encoding with a greedy search. The best bit-packed encoding I found for the data set works like this: 1 bit small per delta component followed by 5 bits if small [-16,+15] range, otherwise the delta component is in [-256,+255] range and is sent with 9 bits. If any component delta values are outside the large range, fallback to absolute position. Using this encoding I was able to obtain on average 26.1 bits for changed positions values.&lt;/p&gt;

&lt;h2 id=&#34;delta-encoding-smallest-three&#34;&gt;Delta Encoding Smallest Three&lt;/h2&gt;

&lt;p&gt;Next I figured that relative orientation would be a similar easy big win. Problem is that unlike position where the range of the position offset is quite small relative to the total position space, the change in orientation in 100ms is a much larger percentage of total quaternion space.&lt;/p&gt;

&lt;p&gt;I tried a bunch of stuff without good results. I tried encoding the 4D vector of the delta orientation directly and recomposing the largest component post delta using the same trick as smallest 3. I tried calculating the relative quaternion between orientation and base orientation, and since I knew that w would be large for this (rotation relative to identity) I could avoid sending 2 bits to identify the largest component, but in turn would need to send one bit for the sign of w because I don&amp;rsquo;t want to negate the quaternion. The best compression I could find using this scheme was only 90% of the smallest three. Not very good.&lt;/p&gt;

&lt;p&gt;I was about to give up but I run some analysis over the smallest three representation. I found that 90% of orientations in the smallest three format had the same largest component index as their base orientation 100ms ago. This meant that it could be profitable to delta encode the smallest three format directly. What&amp;rsquo;s more I found that there would be no additional precision loss with this method when reconstructing the orientation from its base. I exported the quaternion values from a typical run as a data set in smallest three format (available &lt;a href=&#34;http://gafferongames.com/wp-content/uploads/2015/02/smallest_three_values.txt&#34;&gt;here&lt;/a&gt;) and got to work trying the same multi-level small/large range per-component greedy search that I used for position.&lt;/p&gt;

&lt;p&gt;The best encoding found was: 5-8, meaning [-16,+15] small and [-128,+127] large. One final thing: as with position the large range can be extended a bit further by knowing that if the component value is not small the value cannot be in the [-16,+15] range. I leave the calculation of how to do this as an exercise for the reader. Be careful not to collapse two values onto zero.&lt;/p&gt;

&lt;p&gt;The end result is an average of 23.3 bits per-relative quaternion. That&amp;rsquo;s 80.3% of the absolute smallest three.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s just about it but there is one small win left. Doing one final analysis pass over the position and orientation data sets I noticed that 5% of positions are unchanged from the base position after being quantized to 0.5mm resolution, and 5% of orientations in smallest three format are also unchanged from base.&lt;/p&gt;

&lt;p&gt;These two probabilities are mutually exclusive, because if both are the same then the cube would be unchanged and therefore not sent, meaning a small statistical win exists for 10% of cube state if we send one bit for position changing, and one bit for orientation changing. Yes, 90% of cubes have 2 bits overhead added, but the 10% of cubes that save 20+ bits by sending 2 bits instead of 23.3 bit orientation or 26.1 bits position make up for that providing a small overall win of roughly 2 bits per-cube.&lt;/p&gt;

&lt;video controls=&#34;controls&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_delta_end_result.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/cubes_compression_delta_end_result.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;As you can see the end result is pretty good.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;And that&amp;rsquo;s about as far as I can take it using traditional hand-rolled bit-packing techniques. You can find source code for my implementation of all compression techniques mentioned in this article &lt;a href=&#34;https://gist.github.com/gafferongames/bb7e593ba1b05da35ab6&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to get even better compression using a different approach. Bit-packing is inefficient because not all bit values have equal probability of 0 vs 1. No matter how hard you tune your bit-packer a context aware arithmetic encoding can beat your result by more accurately modeling the probability of values that occur in your data set. This &lt;a href=&#34;https://github.com/rygorous/gaffer_net/blob/master/main.cpp&#34;&gt;implementation&lt;/a&gt; by Fabian Giesen beat my best bit-packed result by 25%.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible to get a much better result for delta encoded orientations using the previous baseline orientation values to estimate angular velocity and predict future orientations rather than delta encoding the smallest three representation directly. Chris Doran from Geomerics wrote also wrote an excellent &lt;a href=&#34;http://www.geomerics.com/wp-content/uploads/2015/04/rotation_blog_toprint.pdf&#34;&gt;article&lt;/a&gt; exploring the mathematics of quaternion compression that is worth reading.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NEXT ARTICLE&lt;/strong&gt;: &lt;a href=&#34;http://gafferongames.com/networked-physics/state-synchronization/&#34;&gt;State Synchronization&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Snapshots and Interpolation</title>
      <link>http://173.255.195.190/gafferongames/post/snapshots_and_interpolation/</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/snapshots_and_interpolation/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m &lt;a href=&#34;http://173.255.195.190/gafferongames/about&#34;&gt;Glenn Fiedler&lt;/a&gt; and welcome to &lt;strong&gt;&lt;a href=&#34;http://173.255.195.190/gafferongames/categories/networked-physics/&#34;&gt;Networked Physics&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://gafferongames.com/networked-physics/deterministic-lockstep/&#34;&gt;previous article&lt;/a&gt; we networked a physics simulation using deterministic lockstep. Now, in this article we&amp;rsquo;re going to network the same simulation with a completely different technique: &lt;strong&gt;snapshot interpolation&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Why a different technique? While deterministic lockstep is very efficient in terms of bandwidth, it&amp;rsquo;s not always possible to make your simulation deterministic. Also, as the player count increases, deterministic lockstep becomes problematic: you can&amp;rsquo;t simulate frame n until you receive input from &lt;em&gt;all&lt;/em&gt; players for that frame, so players end up waiting for the most lagged player. Because of this, I recommend deterministic lockstep for 2-4 players at most.&lt;/p&gt;

&lt;p&gt;If your simulation is not deterministic or you want higher player counts then you need a different technique. Snapshot interpolation fits the bill nicely. It is in many ways the polar opposite of deterministic lockstep: instead of running two simulations, one on the left and one on the right, and using synchronized inputs and perfect determinism to make sure they stay in perfectly in sync&amp;hellip; &lt;em&gt;with snapshot interpolation we don&amp;rsquo;t run any simulation on the right side at all!&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;snapshots&#34;&gt;Snapshots&lt;/h2&gt;

&lt;p&gt;Instead, we capture a &lt;strong&gt;snapshot&lt;/strong&gt; of all relevant state from the simulation on the left and transmit it to the right, and on the right side, use those snapshots to reconstruct a visual approximation of the simulation, all without running the simulation itself.&lt;/p&gt;

&lt;p&gt;As a first pass, let&amp;rsquo;s send across the state required to render each cube:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct CubeState
    {
        bool interacting;
        vec3f position;
        quat4f orientation;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m sure you&amp;rsquo;ve worked out by now that the cost of this technique is increased bandwidth usage. Greatly increased bandwidth usage. Hold on to your neckbeards, because a snapshot contains the visual state for the entire simulation. With a bit of math we can see that each cube serializes down to 225 bits or 28.1 bytes. Since there are 900 cubes in our simulation that means each snapshot is roughly 25 kilobytes. That&amp;rsquo;s pretty big!&lt;/p&gt;

&lt;p&gt;At this point I would like everybody to relax, take a deep breath, and imagine we live in a world where I can actually send a packet this large 60 times per-second over the internet and not have everything explode. Imagine I have FIOS &lt;em&gt;(I do)&lt;/em&gt;, or I&amp;rsquo;m sitting over a backbone link to another computer that is also on the backbone. Imagine I live in South Korea. Do whatever you need to do to suspend disbelief, but most of all, don&amp;rsquo;t worry, because I&amp;rsquo;m going to spend the entire next article showing you how to optimize snapshot bandwidth.&lt;/p&gt;

&lt;p&gt;When we send snapshot data in packets, we include at the top a 16 bit sequence number. This sequence number starts at zero and increases with each packet sent. We use this sequence number on receive to determine if the snapshot in a packet is newer or older than the most recent snapshot received. If it&amp;rsquo;s older then it&amp;rsquo;s thrown away.&lt;/p&gt;

&lt;p&gt;Each frame we just render the most recent snapshot received on the right:&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_60pps_jitter.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_60pps_jitter.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;Look closely though, and even though we&amp;rsquo;re sending the data as rapidly as possible (one packet per-frame) you can still see hitches on the right side. This is because the internet makes no guarantee that packets sent 60 times per-second nicely spaced 1/60th of a second apart. Packets are jittered. Some frames you receive two snapshot packets. Other frames you receive none.&lt;/p&gt;

&lt;h1 id=&#34;jitter-and-hitches&#34;&gt;Jitter and Hitches&lt;/h1&gt;

&lt;p&gt;This is actually a really common thing when you first start networking. You start out playing your game over LAN and notice you can just slam out packets really fast (60pps) and most of the time your game looks great because over the LAN those packets actually do tend to arrive at the same rate they were sent&amp;hellip; and then you start trying to play your game over wireless or the internet and you start seeing hitches. Don&amp;rsquo;t worry. There are ways to handle this!&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s look at how much bandwidth we&amp;rsquo;re sending with this naive approach. Each packet is 25312.5 bytes plus 28 bytes for IP + UDP header and 2 bytes for sequence number. That&amp;rsquo;s 25342.5 bytes per-packet and at 60 packets per-second this gives a total of 1520550 bytes per-second or 11.6 megabit/sec. Now there are certainly internet connections out there that can support that amount of traffic&amp;hellip; but since, let&amp;rsquo;s be honest, we&amp;rsquo;re not really getting a lot of benefit blasting packets out 60 times per-second with all the jitter, let&amp;rsquo;s pull it back a bit and send only 10 snapshots per-second:&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_no_interpolation.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_no_interpolation.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;You can see how this looks above. Not so great on the right side but at least we&amp;rsquo;ve reduced bandwidth by a factor of six to around 2 megabit/sec. We&amp;rsquo;re definitely headed in the right direction.&lt;/p&gt;

&lt;h2 id=&#34;linear-interpolation&#34;&gt;Linear Interpolation&lt;/h2&gt;

&lt;p&gt;Now for the trick with snapshots. What we do is instead of immediately rendering snapshot data received is that we buffer snapshots for a short amount of time in an interpolation buffer. This interpolation buffer holds on to snapshots for a period of time such that you have not only the snapshot you want to render but also, statistically speaking, you are very likely to have the next snapshot as well. Then as the right side moves forward in time we interpolate between the position and orientation for the two slightly delayed snapshots providing the illusion of smooth movement. In effect, we&amp;rsquo;ve traded a small amount of added latency for smoothness.&lt;/p&gt;

&lt;p&gt;You may be surprised at just how good it looks with linear interpolation @ 10pps:&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_linear_interpolation.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_linear_interpolation.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;Look closely though and you can see some artifacts on the right side. The first is a subtle position jitter when the player cube is hovering in the air. This is your brain detecting 1st order discontinuity at the sample points of position interpolation. The other artifact occurs when a bunch of cubes are in a katamari ball, you can see a sort of &amp;ldquo;pulsing&amp;rdquo; as the speed of rotation increases and decreases. This occurs because attached cubes interpolate linearly between two sample points rotating around the player cube, effectively interpolating &lt;em&gt;through&lt;/em&gt; the player cube as they take the shortest linear path between two points on a circle.&lt;/p&gt;

&lt;h2 id=&#34;hermite-interpolation&#34;&gt;Hermite Interpolation&lt;/h2&gt;

&lt;p&gt;I find these artifacts unacceptable but I don&amp;rsquo;t want to increase the packet send rate to fix them. Let&amp;rsquo;s see what we can do to make it look better at the same send rate instead. One thing we can try is upgrading to a more accurate interpolation scheme for position, one that interpolates between position samples while considering the linear velocity at each sample point.&lt;/p&gt;

&lt;p&gt;A spline that can be used to perform this interpolation is the &lt;a href=&#34;http://en.wikipedia.org/wiki/Hermite_interpolation&#34;&gt;hermite spline&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike other splines with control points that affect the curve indirectly, the hermite spline is guaranteed to pass through the start and end points while matching the start and end velocities. This means that velocity is smooth across sample points and cubes in the katamari ball tend to rotate around the cube rather than interpolate through it at speed.&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_hermite_interpolation.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_hermite_interpolation.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;Above you can see hermite interpolation for position @ 10pps. Bandwidth has increased slightly because we need to include linear velocity with each cube in the snapshot, but we&amp;rsquo;re able to significantly increase the quality at the same send rate. I can no longer see any artifacts. Go back and compare this with the raw, non-interpolated 10pps version. It really is amazing that we&amp;rsquo;re able to reconstruct the simulation with this level of quality at such a low send rate.&lt;/p&gt;

&lt;p&gt;As an aside, I found it was not necessary to perform higher order interpolation for orientation quaternions to get smooth interpolation. This is great because I did a lot of research into exactly interpolating between orientation quaternions with a specified angular velocity at sample points and it seemed difficult. All that was needed to achieve an acceptable result was to switch from linear interpolation + normalize (nlerp) to spherical linear interpolation (slerp) to ensure constant angular speed for orientation interpolation.&lt;/p&gt;

&lt;p&gt;I believe this is because cubes in the simulation tend to have mostly constant angular velocity while in the air and large angular velocity changes occur only discontinuously when collisions occur. It could also be because orientation tends to change slowly while in the air vs. position which changes rapidly relative to the number of pixels affected on screen. Either way, it seems that slerp is good enough and that&amp;rsquo;s great because it means we don&amp;rsquo;t need to send angular velocity in the snapshot.&lt;/p&gt;

&lt;h2 id=&#34;handling-real-world-conditions&#34;&gt;Handling Real World Conditions&lt;/h2&gt;

&lt;p&gt;Now we have to deal with packet loss. After the discussion of UDP vs. TCP in the previous article I&amp;rsquo;m sure you can see why we would never consider sending snapshots over TCP. Snapshots are time critical but unlike inputs in deterministic lockstep snapshots don&amp;rsquo;t need to be reliable. If a snapshot is lost we can just skip past it and interpolate towards a more recent snapshot in the interpolation buffer. We don&amp;rsquo;t ever want to stop and wait for a lost snapshot packet to be resent. This is why you should always use UDP for sending snapshots.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll let you in on a secret. Not only were the linear and hermite interpolation videos above recorded at a send rate of 10 packets per-second, they were also recorded at 5% packet loss with +/- 2 frames of jitter @ 60fps. How I handled packet loss and jitter for those videos is by simply ensuring that snapshots are held in the interpolation buffer for an appropriate amount of time before interpolation.&lt;/p&gt;

&lt;p&gt;My rule of thumb is that the interpolation buffer should have enough delay so that I can lose two packets in a row and still have something to interpolate towards. Experimentally I&amp;rsquo;ve found that the amount of delay that works best at 2-5% packet loss is 3X the packet send rate. At 10 packets per-second this is 300ms. I also need some extra delay to handle jitter, which in my experience is typically only one or two frames @ 60fps, so the interpolation videos above were recorded with a delay of 350ms.&lt;/p&gt;

&lt;p&gt;Adding 350 milliseconds delay seems like a lot. And it is. But, if you try to skimp you end up hitching for 1/10th of a second each time a packet is lost. One technique that people often use to hide the delay added by the interpolation buffer in other areas (such as FPS, flight simulator, racing games and so on) is to use extrapolation. But in my experience, extrapolation doesn&amp;rsquo;t work very well for rigid bodies because their motion is non-linear and unpredictable. Here you can see an extrapolation of 200ms, reducing overall delay from 350 ms to just 150ms:&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_extrapolation.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/snapshot_interpolation_10pps_extrapolation.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;Problem is it&amp;rsquo;s just not very good. The reason is that the extrapolation doesn&amp;rsquo;t know anything about the physics simulation. Extrapolation doesn&amp;rsquo;t know about collision with the floor so cubes extrapolate down through the floor and then spring back up to correct. Prediction doesn&amp;rsquo;t know about the spring force holding the player cube up in the air so it the cube moves slower initially upwards than it should and has to snap to catch up. It also doesn&amp;rsquo;t know anything about collision and how collision response works, so the cube rolling across the floor and other cubes are also mispredicted. Finally, if you watch the katamari ball you&amp;rsquo;ll see that the extrapolation predicts the attached cubes as continuing to move along their tangent velocity when they should rotate with the player cube.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;You could conceivably spend a great deal of time to improve the quality of this extrapolation and make it aware of various movement modes for the cubes. You could take each cube and make sure that at minimum the cube doesn&amp;rsquo;t go through the floor. You could add some approximate collision detection or response using bounding spheres between cubes. You could even take the cubes in the katamari ball and make them predict motion to rotate around with the player cube.&lt;/p&gt;

&lt;p&gt;But even if you do all this there will still be misprediction because you simply can&amp;rsquo;t accurately match a physics simulation with an approximation. If your simulation is mostly linear motion, eg. fast moving planes, boats, space ships &amp;ndash; you may find that a simple extrapolation works well for short time periods (50-250ms or so), but in my experience as soon as objects start colliding with other non-stationary objects, extrapolation starts to break down.&lt;/p&gt;

&lt;p&gt;How can we reduce the amount of delay added for interpolation? 350ms still seems unacceptable and we can&amp;rsquo;t use extrapolation to reduce this delay without adding a lot of inaccuracy. The solution is simple: &lt;em&gt;increase the send rate!&lt;/em&gt; If we send 30 snapshots per-second we can get the same amount of packet loss protection with a delay of 150ms. 60 packets per-second needs only 85ms.&lt;/p&gt;

&lt;p&gt;In order to increase the send rate we&amp;rsquo;re going to need some pretty good bandwidth optimizations. But don&amp;rsquo;t worry, there&amp;rsquo;s a &lt;em&gt;lot&lt;/em&gt; we can do to optimize bandwidth. So much so that there was too much stuff to fit in this article and I had to insert an extra unplanned article just to cover all of it!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NEXT ARTICLE&lt;/strong&gt;: &lt;a href=&#34;http://gafferongames.com/networked-physics/snapshot-compression/&#34;&gt;Snapshot Compression&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deterministic Lockstep</title>
      <link>http://173.255.195.190/gafferongames/post/deterministic_lockstep/</link>
      <pubDate>Sat, 29 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/deterministic_lockstep/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m &lt;a href=&#34;http://173.255.195.190/gafferongames/about&#34;&gt;Glenn Fiedler&lt;/a&gt; and welcome to &lt;strong&gt;&lt;a href=&#34;http://173.255.195.190/gafferongames/categories/networked-physics/&#34;&gt;Networked Physics&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In this article series we&amp;rsquo;re exploring different ways to network a physics simulation. In this article specifically, we&amp;rsquo;re going to network a physics simulation using deterministic lockstep.&lt;/p&gt;

&lt;p&gt;Deterministic lockstep is a method of networking a system from one computer to another by sending only the &lt;em&gt;inputs&lt;/em&gt; that control that system, rather than the &lt;em&gt;state&lt;/em&gt; of that system. In the context of networking a physics simulation, this means we send across a small amount of input, while avoiding sending state like position, orientation, linear velocity and angular velocity per-object.&lt;/p&gt;

&lt;p&gt;The benefit is that bandwidth is proportional to the size of the input, not the number of objects in the simulation. Yes, with deterministic lockstep you can network a physics simulation of one million objects with the same bandwidth as just one.&lt;/p&gt;

&lt;p&gt;While this sounds great in theory, in practice it&amp;rsquo;s difficult to implement deterministic lockstep because most physics simulations are not deterministic. Differences in floating point behavior between compilers, OS&amp;rsquo;s and even instruction sets make it almost impossible to guarantee determinism for floating point calculations.&lt;/p&gt;

&lt;h2 id=&#34;determinism&#34;&gt;Determinism&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s drill down a bit more into this concept of determinism.&lt;/p&gt;

&lt;p&gt;In this context, determinism means that given the same initial condition and the same set of inputs your simulation gives exactly the same result. And I do mean &lt;em&gt;exactly&lt;/em&gt; the same result.&lt;/p&gt;

&lt;p&gt;Not close. Not near enough. &lt;strong&gt;Exactly the same&lt;/strong&gt;. Exact down to the bit-level. So exact, you could take a checksum of your entire physics state at the end of each frame and it would be identical.&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_desync.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_desync.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;Above you can see a simulation that is &lt;em&gt;almost&lt;/em&gt; deterministic. The simulation on the left is controlled by the player. The simulation on the right has exactly the same inputs applied with a two second delay starting from the same initial condition. Both simulations step forward with the same delta time (a necessary precondition to ensure exactly the same result) and both simulations apply the same inputs. Notice how after the smallest divergence the simulation gets further and further out of sync. This simulation is &lt;strong&gt;non-deterministic&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s going on is that the physics engine I&amp;rsquo;m using (&lt;a href=&#34;http://opende.org&#34;&gt;Open Dynamics Engine&lt;/a&gt;) uses a random number generator inside its solver to randomize the order of constraint processing to improve stability. It&amp;rsquo;s open source. Take a look and see! Unfortunately this breaks determinism because the simulation on the left processes constraints in a different order to the simulation on the right, leading to slightly different results.&lt;/p&gt;

&lt;p&gt;Luckily all that is required to make ODE deterministic on the same machine, with the same complied binary and on the same OS (is that enough qualifications?) is to set its internal random seed to the current frame number before running the simulation via dSetRandomSeed. Once this is done ODE gives exactly the same result and the left and right simulations stay in sync.&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;And now a word of warning. Even though the simulation above is deterministic on the same machine, that does &lt;em&gt;not&lt;/em&gt; necessarily mean it would also be deterministic across different compilers, a different OS or different machine architectures (eg. PowerPC vs. Intel). In fact, it&amp;rsquo;s probably not even deterministic between debug and release builds due to floating point optimizations.&lt;/p&gt;

&lt;p&gt;Floating point determinism is a complicated subject and there&amp;rsquo;s no silver bullet.&lt;/p&gt;

&lt;p&gt;For more information please refer to this &lt;a href=&#34;http://gafferongames.com/networking-for-game-programmers/floating-point-determinism/&#34;&gt;article&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;networking-inputs&#34;&gt;Networking Inputs&lt;/h2&gt;

&lt;p&gt;Now that I have impressed upon you the complexity of perfect determinism, let&amp;rsquo;s get down to implementation, assuming your simulation is in fact deterministic.&lt;/p&gt;

&lt;p&gt;You may wonder what the input in our example simulation is and how we should network it. Well, our example physics simulation is driven by keyboard input: arrow keys apply forces to make the player cube move, holding space lifts the cube up and blows other cubes around, and holding &amp;lsquo;z&amp;rsquo; enables katamari mode.&lt;/p&gt;

&lt;p&gt;But how can we network these inputs? Must we send the entire state of the keyboard? No. It&amp;rsquo;s not necessary to send the entire keyboard state, only the state of the keys that affect the simulation. What about key press and release events then? No. This is also not a good strategy. We need to ensure that exactly the same input is applied on the right side, at exactly the same time, so we can&amp;rsquo;t just send &amp;lsquo;key pressed&amp;rsquo;, and &amp;lsquo;key released&amp;rsquo; events over TCP.&lt;/p&gt;

&lt;p&gt;What we do instead is represent the input with a struct and at the beginning of each simulation frame on the left side, sample this struct from the keyboard:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    struct Input
    {
        bool left;
        bool right;
        bool up;
        bool down;
        bool space;
        bool z;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we send that input from the left simulation to the right simulation in a way that the simulation on the right side knows that the input belongs to frame n.&lt;/p&gt;

&lt;p&gt;And here&amp;rsquo;s the key part: the simulation on the right can only simulate frame n when it has the input for that frame. If it doesn&amp;rsquo;t have the input, it has to wait.&lt;/p&gt;

&lt;p&gt;For example, if you were sending across using TCP you could simply send the inputs and nothing else, and on the other side you could read the packets coming in, and each input received corresponds to one frame for the simulation to step forward. If no input arrives for a given render frame, the right side can&amp;rsquo;t advance forward, it has to wait for the next input to arrive.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say you&amp;rsquo;re using TCP, you&amp;rsquo;ve disabled &lt;a href=&#34;http://en.wikipedia.org/wiki/Nagle&#39;s_algorithm&#34;&gt;Nagle&amp;rsquo;s Algorithm&lt;/a&gt;, and you&amp;rsquo;re sending inputs from the left to the right simulation once per-frame (60 times per-second).&lt;/p&gt;

&lt;p&gt;Here it gets a little complicated. Since we can&amp;rsquo;t simulate forward unless we have the input for the next frame, it&amp;rsquo;s not enough to just take whatever inputs arrive over the network and then run the simulation on inputs as they arrive because the result would be very jittery. Data sent across the network at 60HZ doesn&amp;rsquo;t typically arrive nicely spaced, 1/60th of a second between each packet.&lt;/p&gt;

&lt;p&gt;If you want this sort of behavior, you have to implement it yourself.&lt;/p&gt;

&lt;h2 id=&#34;playout-delay-buffer&#34;&gt;Playout Delay Buffer&lt;/h2&gt;

&lt;p&gt;Such a device is called a playout delay buffer.&lt;/p&gt;

&lt;p&gt;Unfortunately, the subject of playout delay buffers is a patent minefield. I would not advise searching for &amp;ldquo;playout delay buffer&amp;rdquo; or &amp;ldquo;adaptive playout delay&amp;rdquo; while at work. But in short, what you want to do is buffer packets for a short amount of time so they &lt;em&gt;appear&lt;/em&gt; to be arriving at a steady rate even though in reality they arrive somewhat jittered.&lt;/p&gt;

&lt;p&gt;What you&amp;rsquo;re doing here is similar to what Netflix does when you stream a video. You pause a little bit initially so you have a buffer in case some packets arrive late and then once the delay has elapsed video frames are presented spaced the correct time apart. If your buffer isn&amp;rsquo;t large enough then the video playback will be hitchy. With deterministic lockstep your simulation behaves exactly the same way: showing hitches when the buffer isn&amp;rsquo;t large enough to smooth out the jitter. Of course, the cost of increasing the buffer size is additional latency, so you can&amp;rsquo;t just buffer your way out of all problems. At some point the user says enough! That&amp;rsquo;s too much latency added. No sir, I will &lt;em&gt;not&lt;/em&gt; play your game with 1 second of extra delay :)&lt;/p&gt;

&lt;p&gt;My playout delay buffer implementation is really simple. You add inputs to it indexed by frame, and when the very first input is received, it stores the current local time on the receiver machine and from that point on delivers packets assuming they should play at that time + 100ms. You&amp;rsquo;ll likely need to something more complex for a real world situation, perhaps something that handles clock drift, and detecting when the simulation should slightly speed up or slow down to maintain a nice amount of buffering safety (being &amp;ldquo;adaptive&amp;rdquo;) while minimizing overall latency, but this is reasonably complicated and probably worth an article in itself.&lt;/p&gt;

&lt;p&gt;The goal is that under average conditions the playout delay buffer provides a steady stream of inputs for frame n, n+1, n+2 and so on, nicely spaced 1/60th of a second apart with no drama. In the worst case the time arrives for frame n and the input hasn&amp;rsquo;t arrived yet it returns null and the simulation is forced to wait. If packets get bunched up and delivered late, it&amp;rsquo;s possibly to have multiple inputs ready to dequeue per-frame. In this case I limit to 4 simulated frames per-render frame so the simulation has a chance to catch up, but doesn&amp;rsquo;t simulate for so long that it falls further behind, aka. the &amp;ldquo;spiral of death&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;is-tcp-good-enough&#34;&gt;Is TCP good enough?&lt;/h2&gt;

&lt;p&gt;Using this playout buffer strategy and sending inputs across TCP we ensure that all inputs arrive reliably and in-order. This is convenient, and after all, TCP is designed for exactly this situation: reliable-ordered data.&lt;/p&gt;

&lt;p&gt;In fact, It&amp;rsquo;s a common thing out there on the Internet for pundits to say stuff like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.reddit.com/r/gamedev/comments/1tvbe0/is_it_just_me_or_is_networking_really_hard/&#34;&gt;If you need reliable-ordered, you can&amp;rsquo;t do better than TCP!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://thoughtstreams.io/glyph/your-game-doesnt-need-udp-yet/&#34;&gt;Your game doesn&amp;rsquo;t need UDP (yet)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But I&amp;rsquo;m here to tell you this kind of thinking is &lt;u&gt;&lt;b&gt;dead wrong&lt;/b&gt;&lt;/u&gt;.&lt;/p&gt;

&lt;video autoplay preload=&#34;auto&#34; loop=&#34;true&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_tcp_100ms_1pc.mp4&#34; type=&#34;video/mp4&#34;/&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_tcp_100ms_1pc.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;Above you can see the simulation networked using deterministic lockstep over TCP at 100ms latency and 1% packet loss. If you look closely on the right side you can see hitches every few seconds. What&amp;rsquo;s happening here is that each time a packet is lost, TCP has to wait RTT*2 while it is resent (actually it can be much worse, but I&amp;rsquo;m being generous&amp;hellip;). The hitches happen because with deterministic lockstep the right simulation can&amp;rsquo;t simulate frame n without input n, so it has to pause to wait for input n to be resent!&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s not all. It gets significantly worse as latency and packet loss increase. Here is the same simulation networked using deterministic lockstep over TCP at 250ms latency and 5% packet loss:&lt;/p&gt;

&lt;video autoplay preload=&#34;auto&#34; loop=&#34;true&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_tcp_250ms_5pc.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_tcp_250ms_5pc.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;Now I will concede that if you have no packet loss and/or a very small amount of latency then you very well may get acceptable results with TCP. But please be aware that if you use TCP to send time critical data it degrades &lt;em&gt;&lt;u&gt;terribly&lt;/u&gt;&lt;/em&gt; as packet loss and latency increase.&lt;/p&gt;

&lt;h2 id=&#34;can-we-do-better-than-tcp&#34;&gt;Can we do better than TCP?&lt;/h2&gt;

&lt;p&gt;Can we beat TCP at its own game. Reliable-ordered delivery?&lt;/p&gt;

&lt;p&gt;The answer is an emphatic &lt;b&gt;YES&lt;/b&gt;. But &lt;em&gt;only&lt;/em&gt; if we change the rules of the game.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the trick. We need to ensure that all inputs arrive reliably and in order. But if we send inputs in UDP packets, some of those packets will be lost. What if, instead of detecting packet loss after the fact and resending lost packets, we redundantly include &lt;em&gt;all inputs&lt;/em&gt; in each UDP packet until we know for sure the other side has received them?&lt;/p&gt;

&lt;p&gt;Inputs are very small (6 bits). Let&amp;rsquo;s say we&amp;rsquo;re sending 60 inputs per-second (60fps simulation) and round trip time we know is going the be somewhere in 30-250ms range. Let&amp;rsquo;s say just for fun that it could be up to 2 seconds worst case and at this point we&amp;rsquo;ll time out the connection (screw that guy). This means that on average we only need to include between 2-15 frames of input and worst case we&amp;rsquo;ll need 120 inputs. Worst case is 120*6 = 720 bits. That&amp;rsquo;s only 90 bytes of input! That&amp;rsquo;s totally reasonable.&lt;/p&gt;

&lt;p&gt;We can do even better. It&amp;rsquo;s not common for inputs to change every frame. What if when we send our packet instead we start with the sequence number of the most recent input, and the 6 bits of the first (oldest) input, and the number of un-acked inputs. Then as we iterate across these inputs to write them to the packet we can write a single bit (1) if the next input is different to the previous, and (0) if the input is the same. So if the input is different from the previous frame we write 7 bits (rare). If the input is identical we write just one (common). Where inputs change infrequently this is a big win and in the worst case this really isn&amp;rsquo;t that bad. 120 bits of extra data sent. Just 15 bytes overhead worst case.&lt;/p&gt;

&lt;p&gt;Of course another packet is required from the right simulation to the left so the left side knows which inputs have been received. Each frame the right simulation reads input packets from the network before adding them to the playout delay buffer and keeps track of the most recent input it has received and sends this back to the left as an &amp;ldquo;ack&amp;rdquo; or acknowledgment for inputs.&lt;/p&gt;

&lt;p&gt;When the left side receives this ack it discards any inputs older than the most recent received input. This way we have only a small number of inputs in flight proportional to the round trip time between the two simulations.&lt;/p&gt;

&lt;h2 id=&#34;flawless-victory&#34;&gt;Flawless Victory&lt;/h2&gt;

&lt;p&gt;We have beaten TCP by changing the rules of the game.&lt;/p&gt;

&lt;p&gt;Instead of &amp;ldquo;implementing 95% of TCP on top of UDP&amp;rdquo; we have implemented something &lt;em&gt;totally different&lt;/em&gt; and better suited to our requirements. A protocol that redundantly sends inputs because we know they are small, so we never have to wait for retransmission.&lt;/p&gt;

&lt;p&gt;So exactly how much better is this approach than sending inputs over TCP?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look&amp;hellip;&lt;/p&gt;

&lt;video autoplay preload=&#34;auto&#34; loop=&#34;true&#34; width=&#34;100%&#34;&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_udp_2sec_25pc.mp4&#34; type=&#34;video/mp4&#34;/&gt;
  &lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/deterministic_lockstep_udp_2sec_25pc.webm&#34; type=&#34;video/webm&#34;/&gt;
&lt;/video&gt;

&lt;p&gt;The video above shows deterministic lockstep synchronized over UDP using this technique with &lt;u&gt;2 seconds&lt;/u&gt; of latency and &lt;u&gt;25% packet loss&lt;/u&gt;. Imagine how awful TCP would look under these conditions.&lt;/p&gt;

&lt;p&gt;So in conclusion, even where TCP should have the most advantage, in the only networking model I&amp;rsquo;ll present to you in this article series that relies on reliable-ordered data, we can easily beat it with a simple protocol sent over UDP.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Physics Simulation</title>
      <link>http://173.255.195.190/gafferongames/post/the_physics_simulation/</link>
      <pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/the_physics_simulation/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m &lt;a href=&#34;http://173.255.195.190/gafferongames/about&#34;&gt;Glenn Fiedler&lt;/a&gt; and welcome to the first article in &lt;strong&gt;&lt;a href=&#34;http://173.255.195.190/gafferongames/categories/networked-physics/&#34;&gt;Networked Physics&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In this article series we&amp;rsquo;re going to network a physics simulation three different ways: deterministic lockstep, snapshot interpolation and state synchronization.&lt;/p&gt;

&lt;p&gt;But before we get to this, lets spend some time exploring the physics simulation we’re going to network.&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cube.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cube.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;Here I’ve setup a simple simulation of a cube in the open source physics engine &lt;a href=&#34;http://www.ode.org&#34;&gt;ODE&lt;/a&gt;. The player moves around by applying forces at its center of mass. The physics simulation takes this linear motion and calculates friction as the cube collides with the ground, inducing a rolling and tumbling motion.&lt;/p&gt;

&lt;p&gt;This tumbling is why I chose a cube instead a sphere. I &lt;em&gt;want&lt;/em&gt; this complex, unpredictable motion because rigid bodies in general move in interesting ways according to their shape. It’s simply not possible to accurately predict the motion of a rigid body with a linear extrapolation or the ballistic equations of motion.&lt;/p&gt;

&lt;p&gt;If you want to know where a rigid body is at a future time, you have to run the whole physics simulation: dynamics, collision detection, collision response and friction in order to find out!&lt;/p&gt;

&lt;h2 id=&#34;an-interactive-world&#34;&gt;An Interactive World&lt;/h2&gt;

&lt;p&gt;Networking a physics simulation is easy if there is only one object interacting with a static world. It starts to get interesting when the player interacts with other physically simulated objects, &lt;em&gt;especially&lt;/em&gt; when those objects push back and affect the motion of the player.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add some more cubes to the simulation:&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cubes_roll.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cubes_roll.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;Notice when the player interacts with a cube it turns red. When that cube comes to rest it turns back to grey (non-interacting). Interactions aren’t just direct. Red cubes hit by the player turn other cubes they touch red as well. This way player interactions fan-out covering all affected objects.&lt;/p&gt;

&lt;p&gt;While it’s cool to roll around and interact with other cubes, what I really wanted was a way to push &lt;em&gt;lots&lt;/em&gt; of cubes around. What I came up with is this:&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cubes_blow.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cubes_blow.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;To implement this I raycast to find the intersection with the ground below the center of mass of the player cube, then apply a spring force (see &lt;a href=&#34;https://en.wikipedia.org/wiki/Hooke%27s_law&#34;&gt;Hooke’s law&lt;/a&gt;) relative to the distance from this point, making the player cube float in the air.&lt;/p&gt;

&lt;p&gt;Then all non-player cubes within a certain distance of that intersection point have a force applied proportional to their distance from this point and away from it, so they are pushed away out of the way like leaves from a leaf blower.&lt;/p&gt;

&lt;h2 id=&#34;a-complicated-case&#34;&gt;A Complicated Case&lt;/h2&gt;

&lt;p&gt;I also wanted a very complex coupled motion between the player and non-player cubes such that the player and the objects its interacting with become one single system, a group of rigid bodies joined together by constraints.&lt;/p&gt;

&lt;p&gt;To implement this I thought it would be cool if the player could roll around and create a ball of cubes, like in one of my favorite games &lt;a href=&#34;https://en.wikipedia.org/wiki/Katamari_Damacy&#34;&gt;Katamari Damacy&lt;/a&gt;.&lt;/p&gt;

&lt;video preload=&#34;auto&#34; autoplay=&#34;autoplay&#34; loop=&#34;loop&#34; width=&#34;100%&#34;&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cubes_katamari.mp4&#34; type=&#34;video/mp4&#34; /&gt;
&lt;source src=&#34;http://173.255.195.190/gafferongames/video/networked_physics/the_physics_simulation_cubes_katamari.webm&#34; type=&#34;video/webm&#34; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;

&lt;p&gt;To implement this effect cubes within a certain distance of the player have a force applied towards the center of the cube. These cubes remain physically simulated while in the katamari ball, they are not just “stuck” to the player like in the original game.&lt;/p&gt;

&lt;p&gt;This means that the cubes in the katamari are continually pushing and interacting with each other and the player cube via collision constraints.&lt;/p&gt;

&lt;p&gt;This is a very difficult situation for networked physics.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Collision Response and Coulomb Friction</title>
      <link>http://173.255.195.190/gafferongames/post/collision_response_and_coulomb_friction/</link>
      <pubDate>Sun, 24 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/collision_response_and_coulomb_friction/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to &lt;a href=&#34;http://173.255.195.190/gafferongames/categories/virtual-go/&#34;&gt;&lt;strong&gt;Virtual Go&lt;/strong&gt;&lt;/a&gt;, my project to create a physically accurate computer simulation of a Go board and stones.&lt;/p&gt;

&lt;p&gt;So far in this series, we have mathematically defined the go stone, rendered it, determined how it moves and rotates, and discussed how its shape affects how it responds to collisions.&lt;/p&gt;

&lt;p&gt;Now in this article we reach our first milestone:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A go stone bouncing and coming to rest on the go board&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/board-side-on-swirling-wood-grain.jpg&#34; alt=&#34;stones at rest on board&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re going do this using a technique called &lt;a href=&#34;https://en.wikipedia.org/wiki/Collision_response#Impulse-Based_Contact_Model&#34;&gt;impulse-based collision response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The concept is simple. To handle a collision we apply an impulse, an instantaneous change in momentum, at the point of impact to make the go stone bounce.&lt;/p&gt;

&lt;h2 id=&#34;linear-collision-response&#34;&gt;Linear Collision Response&lt;/h2&gt;

&lt;p&gt;We now pick up where we left off at the end of the &lt;a href=&#34;http://gafferongames.com/virtualgo/collision-detection-go-stone-vs-go-board/&#34;&gt;collision detection article&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/contact-point-linear.png&#34; alt=&#34;contact point linear&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;We have a contact point and a contact normal for the collision.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start by calculating a collision response impulse without rotation.&lt;/p&gt;

&lt;p&gt;First, take the dot product of the linear momentum of the go stone with the contact normal. If this value is less than zero, it means the go stone is moving towards the go board, and we need to apply an impulse.&lt;/p&gt;

&lt;p&gt;To calculate the impulse we need the concept of &amp;lsquo;elasticity&amp;rsquo;. If the collision is perfectly elastic, the go stone bounces off the board without losing any energy:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/linear-collision-response-elastic.png&#34; alt=&#34;linear collision response elastic&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;If the collision is inelastic then the go stone loses all its vertical motion post-collision and slides along the surface of the board:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/linear-collision-response-inelastic.png&#34; alt=&#34;linear collision response inelastic&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;What we really want is something in between:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/linear-collision-response-coefficient-of-restitution.png&#34; alt=&#34;linear collision response coefficient of restitution&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;To support this we introduce a new concept called the &amp;lsquo;coefficient of restitution&amp;rsquo;. When this value is 1 the collision is perfectly elastic, when it is 0 the collision is inelastic. At 0.5, it&amp;rsquo;s halfway between.&lt;/p&gt;

&lt;p&gt;This gives the following formula:&lt;/p&gt;

&lt;p&gt;[latex]j = -( 1 + e ) \boldsymbol{p} \cdot \boldsymbol{n}[/latex]&lt;/p&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;j is the magnitude of the collision impulse&lt;/li&gt;
&lt;li&gt;e is the coefficient of restitution [0,1]&lt;/li&gt;
&lt;li&gt;p is the linear momentum of the go stone&lt;/li&gt;
&lt;li&gt;n in the contact normal for the collision&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the direction of the collision impulse is &lt;u&gt;always&lt;/u&gt; along the contact normal, so to apply the impulse just multiply the contact normal by j and add it to the linear momentum vector.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the code that does this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    void ApplyLinearCollisionImpulse( StaticContact &amp;amp; contact, float e )
    {
        float mass = contact.rigidBody-&amp;gt;mass;
        float d = dot( contact.rigidBody-&amp;gt;linearMomentum, contact.normal );
        float j = max( - ( 1 + e ) * d, 0 );
        contact.rigidBody-&amp;gt;linearMomentum += j * contact.normal;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the result:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/kveh3fgPg6I&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Now the stone is definitely bouncing, but in the real world stones don&amp;rsquo;t usually hit the board perfectly flat like this. In the common case, they hit at an angle and the collision makes the stone rotate.&lt;/p&gt;

&lt;h2 id=&#34;collision-response-with-rotation&#34;&gt;Collision Response With Rotation&lt;/h2&gt;

&lt;p&gt;To capture this effect we need to calculate collision response with rotation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/collision-response-rotation.png&#34; alt=&#34;collision response rotation&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Above you can see the effect that we want. If a stone were to collide with the board like this, we know from experience that it would rotate in response.&lt;/p&gt;

&lt;p&gt;We start by calculating the velocity of the stone at the contact point, and take the dot product of this vs. the contact normal to check if the stone is moving towards the board. This is necessary because when the stone is rotating, different points on the stone have different velocities.&lt;/p&gt;

&lt;p&gt;Next, we apply a collision impulse along the contact normal with magnitude j except this impulse is applied at the contact point instead of the center of mass of the stone. This gives the collision response its rotational effect.&lt;/p&gt;

&lt;p&gt;Here is the general equation for the magnitude of this collision impulse.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/impulse-j-general-case.png&#34; alt=&#34;impulse j general case&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;You can find a derivation of this result on &lt;a href=&#34;https://en.wikipedia.org/wiki/Collision_response#Impulse-Based_Reaction_Model&#34;&gt;wikipedia&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Understandably this is quite complex, but in our case the go board never moves, so we can simplify the equation by assigning zero velocity and infinite mass to the second body. This leads to the following, simpler equation:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;todo: need a solution to convert across all the latex equations&amp;hellip;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;[latex]j = \dfrac{ -( 1 + e ) \boldsymbol{v} \cdot \boldsymbol{n} } { m^{-1} + ( \boldsymbol{I^{-1}} ( \boldsymbol{r} \times \boldsymbol{n} ) \times \boldsymbol{r} ) \cdot \boldsymbol{n} }[/latex]&lt;/p&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;j is the magnitude of the collision impulse&lt;/li&gt;
&lt;li&gt;e is the coefficient of restitution [0,1]&lt;/li&gt;
&lt;li&gt;n in the contact normal for the collision&lt;/li&gt;
&lt;li&gt;v is the the go stone velocity at the contact point&lt;/li&gt;
&lt;li&gt;r is the contact point minus the center of the go stone&lt;/li&gt;
&lt;li&gt;I is the inertia tensor of the go stone&lt;/li&gt;
&lt;li&gt;m is the mass of the go stone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is the result of our collision response with rotational effects:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/SCckKzO_280&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;As you can see, collision response working properly and induces rotation when the go stone hits the board at an angle. It is also able to handle the stone hitting the board while rotating.&lt;/p&gt;

&lt;h2 id=&#34;coulomb-friction&#34;&gt;Coulomb Friction&lt;/h2&gt;

&lt;p&gt;We don&amp;rsquo;t often get to see friction-less collisions in the real world so the video above looks a bit strange. To get realistic behavior out of the go stone, we need to add friction.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll model sliding friction using the Coulomb friction model.&lt;/p&gt;

&lt;p&gt;In this model, the friction impulse is proportional the magnitude of the normal impulse j and is limited by a friction cone defined by the coefficient of friction u:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/coulomb-friction-model.png&#34; alt=&#34;coulomb friction model&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Lower friction coefficient values mean less friction, higher values mean more friction. Typical values for the coefficient of friction are in the range [0,1].&lt;/p&gt;

&lt;p&gt;Calculation of the Coulomb friction impulse is performed much like the calculation of the normal impulse except this time the impulse is in the tangent direction against the direction of sliding.&lt;/p&gt;

&lt;p&gt;Here is the formula for calculating the magnitude of the friction impulse:&lt;/p&gt;

&lt;p&gt;[latex]j_t = \dfrac{ - \boldsymbol{v} \cdot \boldsymbol{t} } { m^{-1} + ( \boldsymbol{I^{-1}} ( \boldsymbol{r} \times \boldsymbol{t} ) \times \boldsymbol{r} ) \cdot \boldsymbol{t} }[/latex]&lt;/p&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;j&lt;sub&gt;t&lt;/sub&gt; is the magnitude of the friction impulse (pre-cone limit)&lt;/li&gt;
&lt;li&gt;u is the coefficient of friction [0,1]&lt;/li&gt;
&lt;li&gt;t in the tangent vector in the direction of sliding&lt;/li&gt;
&lt;li&gt;v is the the go stone velocity at the contact point&lt;/li&gt;
&lt;li&gt;r is the contact point minus the center of the go stone&lt;/li&gt;
&lt;li&gt;I is the inertia tensor of the go stone&lt;/li&gt;
&lt;li&gt;m is the mass of the go stone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Which gives the following result:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/XXMBHkjPdzM&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;This looks much more realistic!&lt;/p&gt;

&lt;h2 id=&#34;rolling-friction&#34;&gt;Rolling Friction&lt;/h2&gt;

&lt;p&gt;Due to its shape (and the inertia tensor from the previous article), the go stone really prefers to rotate about axes on the xz plane instead of around the y axis.&lt;/p&gt;

&lt;p&gt;I was able to reproduct this effect in the simulation. Adding a torque that spins go stone around the y axis made it stand up and spin like a coin:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/bF6kHscHbyw&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;This is pretty cool and is totally emergent from the shape of the go stone. The only problem is that it spins like this &lt;u&gt;forever&lt;/u&gt;.&lt;/p&gt;

&lt;p&gt;Why is it spinning for so long? Shouldn&amp;rsquo;t coulomb friction handle this for us?&lt;/p&gt;

&lt;p&gt;No. Coulomb friction only handles friction when the two surfaces are sliding relative to each other. Here at the point of contact, the stone is spinning about that point, not sliding, so from coulomb friction point of view, the contact point is stationary and no friction is applied.&lt;/p&gt;

&lt;p&gt;It turns out that sliding friction is just one type of friction and there are &lt;a href=&#34;https://en.wikipedia.org/wiki/Friction&#34;&gt;many others&lt;/a&gt;. What we have in this case is a combination of rolling and spinning friction.&lt;/p&gt;

&lt;p&gt;I had very little patience at this point so I came up with my own hack approximation of spinning and rolling friction that gives me the result that I want: vibrant motion at high energies but slightly damped so the stone slows down, collapses from spinning, wobbles a bit and then come to rest.&lt;/p&gt;

&lt;p&gt;My hack was to apply exponential decay (eg. linearVelocity *= factor [0.9990-0.9999] each frame) to linear and angular velocity. The decay factor was linear interpolated between two key speeds such that there was more damping at low speeds and much less at high speeds. There is no physical basis for this, it&amp;rsquo;s just a hack to get the behavior I want.&lt;/p&gt;

&lt;p&gt;With a bit of tuning, it seems to work reasonably well:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/1eG2xTubRJY&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;I&amp;rsquo;m pretty happy with this result :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rotation &amp; Inertia Tensors</title>
      <link>http://173.255.195.190/gafferongames/post/rotation_and_inertia_tensors/</link>
      <pubDate>Sat, 23 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/rotation_and_inertia_tensors/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to &lt;a href=&#34;http://173.255.195.190/gafferongames/categories/virtual-go/&#34;&gt;&lt;strong&gt;Virtual Go&lt;/strong&gt;&lt;/a&gt;, my project to create a physically accurate computer simulation of a Go board and stones.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://173.255.195.190/gafferongames/post/go_stone_vs_go_board/&#34;&gt;previous article&lt;/a&gt; we detected collision between the go stone and the go board. Now we&amp;rsquo;re working up to calculating collision response so the stone bounces and wobbles before coming to rest on the board.&lt;/p&gt;

&lt;p&gt;But in order to reach this goal we first need to lay some groundwork. It turns out that irregularly shaped objects, like go stones, are easier to rotate about some axes than others and this has a large effect on how they react to collisions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/placing-a-stone-on-the-board.jpg&#34; alt=&#34;placing a stone on the board&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;This is the reason go stones wobble in such an interesting way when placed on the go board, and why thick go stones wobble differently to thin ones.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s study this effect so we can reproduce it in Virtual Go.&lt;/p&gt;

&lt;h2 id=&#34;rotation-in-3d&#34;&gt;Rotation in 3D&lt;/h2&gt;

&lt;p&gt;Consider the following case in two dimensions:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/rotation-in-2d.png&#34; alt=&#34;rotation in 2d&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy because there is only one possible axis for rotation: clockwise or counter-clockwise.&lt;/p&gt;

&lt;p&gt;It follows that as long as we are only rotating about the center of mass, we can represent the orientation of an object in 2D with a single theta value, angular velocity with a scalar radians per-second, and a scalar &amp;lsquo;moment of inertia&amp;rsquo; that works just like an angular equivalent of mass: how hard it is to rotate that object.&lt;/p&gt;

&lt;p&gt;When we move to three dimensions suddenly rotation can occur about any axis. Orientation becomes a quaternion, angular velocity a vector, and now for irregular shaped objects like go stones, we need a way to indicate that certain axes of rotation are easier to rotate about than others.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/rotation-in-3d.png&#34; alt=&#34;rotation in 3d&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;But how can we represent an angular mass that depends on the shape of the object and the axis of rotation?&lt;/p&gt;

&lt;h2&gt;Inertia Tensor&lt;/h2&gt;

&lt;p&gt;The solution is to use an &lt;a href=&#34;https://en.wikipedia.org/wiki/Moment_of_inertia#Moment_of_inertia_tensor&#34;&gt;inertia tensor&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An inertia tensor is a 3x3 matrix with different rules to a normal matrix. It rotates and translates differently, but otherwise behaves like a 3x3 matrix and is used to transform angular velocity to angular momentum, and the inverse of the inertia tensor transforms angular momentum to angular velocity.&lt;/p&gt;

&lt;p&gt;Now this becomes quite interesting because Newton&amp;rsquo;s laws guarantee that in a perfectly elastic collision angular momentum is conserved but angular velocity is not necessarily.&lt;/p&gt;

&lt;p&gt;Why is this? Because angular velocity now depends on the axis of rotation, so even if the angular momentum has exactly the same magnitude post-collision the angular velocity can be different if the axis of rotation changes and the inertia tensor is non-uniform.&lt;/p&gt;

&lt;p&gt;Because of this we&amp;rsquo;ll switch to angular momentum as the primary quantity in our physics simulation and we&amp;rsquo;ll derive angular velocity from it. For consistency we&amp;rsquo;ll also switch from linear velocity to linear momentum.&lt;/p&gt;

&lt;h2 id=&#34;calculating-the-inertia-tensor&#34;&gt;Calculating The Inertia Tensor&lt;/h2&gt;

&lt;p&gt;Now we need a way to calculate the inertia tensor of our go stone.&lt;/p&gt;

&lt;p&gt;The general case is quite complicated because inertia tensors are capable of representing shapes that are non-symmetrical about the axis of rotation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;todo: yes, need to sort out the latex equations&amp;hellip;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;[latex]I = \begin{bmatrix} I&lt;em&gt;{xx} &amp;amp; I&lt;/em&gt;{xy} &amp;amp; I&lt;em&gt;{xz} \ I&lt;/em&gt;{yx} &amp;amp; I&lt;em&gt;{yy} &amp;amp; I&lt;/em&gt;{yz} \ I&lt;em&gt;{zx} &amp;amp; I&lt;/em&gt;{zy} &amp;amp; I_{zz} \end{bmatrix}[/latex]&lt;/p&gt;

&lt;p&gt;For example, think of an oddly shaped object attached to a drill bit off-center and wobbling about crazily as the drill spins. Fantastic. But the good news is that we get to dodge this bullet because we are always rotating about the center of mass of the go stone, our inertia tensor is much simpler:&lt;/p&gt;

&lt;p&gt;[latex]I = \begin{bmatrix} I&lt;em&gt;{x} &amp;amp; 0 &amp;amp; 0 \ 0 &amp;amp; I&lt;/em&gt;{y} &amp;amp; 0 \ 0 &amp;amp; 0 &amp;amp; I_{z} \end{bmatrix}[/latex]&lt;/p&gt;

&lt;p&gt;All we need to do in our case is to determine the I&lt;sub&gt;x&lt;/sub&gt;, I&lt;sub&gt;y&lt;/sub&gt; and I&lt;sub&gt;z&lt;/sub&gt; values.&lt;/p&gt;

&lt;p&gt;They represent how difficult it is to rotate the go stone about the x,y and z axes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/inertia-tensor-ix.png&#34; alt=&#34;inertia tensor x&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/inertia-tensor-iy.png&#34; alt=&#34;inertia tensor y&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/inertia-tensor-iz.png&#34; alt=&#34;inertia tensor z&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Interestingly, due to symmetry of the go stone, all axes on the xz plane are identical. So really, we only need to calculate I&lt;sub&gt;x&lt;/sub&gt; and I&lt;sub&gt;y&lt;/sub&gt; because I&lt;sub&gt;z&lt;/sub&gt; = I&lt;sub&gt;x&lt;/sub&gt;.&lt;/p&gt;

&lt;h2 id=&#34;numerical-integration&#34;&gt;Numerical Integration&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s first calculate the inertia tensor via numerical integration.&lt;/p&gt;

&lt;p&gt;To do this we just need to know is how difficult it is rotate a point about an axis.&lt;/p&gt;

&lt;p&gt;Once we know this we can approximate the moment of inertia of a go stone by breaking it up into a discrete number of points and summing up the moments of inertia of all these points.&lt;/p&gt;

&lt;p&gt;It turns out that the difficulty of rotating a point mass about an axis is proportional to the &lt;em&gt;square&lt;/em&gt; of the distance of that point from the axis and the mass of the point. [latex]I = mr^2[/latex]. This is quite interesting because it indicates that the distribution of mass has a significant effect on how difficult it is to rotate an object about an axis.&lt;/p&gt;

&lt;p&gt;One consequence of this is that a hollow pipe is actually more difficult to rotate than a solid pipe of the same mass. Of course, this is not something we deal with in real life often, because a solid pipe of the same material would be much heavier, and therefore harder to rotate due to increased mass, but if you could find a second material of lower density such that the solid pipe was exactly the same mass as the hollow pipe, you would be able to observe this effect. Obscure.&lt;/p&gt;

&lt;p&gt;In our case we know the go stone is solid not hollow, and we can go one step further and assume that the go stone has completely uniform density throughout. This means if we know the mass of the go stone we can divide it by the volume of the go stone to find its density. Then we can divide space around the go stone into a grid, and using this density we can assign a mass to each point in the grid proportional to the density of the go stone.&lt;/p&gt;

&lt;p&gt;Now integration is just a triple for loop summing up the moments of inertia for points that are inside the go stone. This gives us an approximation of the inertia tensor for the go stone that becomes more accurate the more points we use.&lt;/p&gt;

&lt;h2 id=&#34;interpreting-the-inertia-tensor&#34;&gt;Interpreting The Inertia Tensor&lt;/h2&gt;

&lt;p&gt;A size 33 japanese go stone has width 22mm and height 9.2mm:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/clam-shell-stone-size-33.jpg&#34; alt=&#34;size 33 go stone&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Using our point-based approximation to calculate its inertia tensor gives the following result:&lt;/p&gt;

&lt;p&gt;[latex]I = \begin{bmatrix} 0.177721 &amp;amp; 0 &amp;amp; 0 \ 0 &amp;amp; 0.304776 &amp;amp; 0 \ 0 &amp;amp; 0 &amp;amp; 0.177721 \end{bmatrix}[/latex]&lt;/p&gt;

&lt;p&gt;As expected, I&lt;sub&gt;x&lt;/sub&gt; = I&lt;sub&gt;z&lt;/sub&gt; due to the symmetry of the go stone.&lt;/p&gt;

&lt;p&gt;The inertia tensor indicates that its much harder to rotate the go stone about the y axis than axes on the xz plane.&lt;/p&gt;

&lt;p&gt;Why is this?&lt;/p&gt;

&lt;p&gt;You can see looking top-down at the go stone when rotating about the y axis a ring of mass around the edge of the stone is multiplied by a large r&lt;sup&gt;2&lt;/sup&gt; and is therefore difficult to rotate.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/top-down-y-rotation.png&#34; alt=&#34;top down y rotation&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Contrast this with the rotation about the z axis, which has a much smaller portion of mass far away from the axis:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/top-down-z-rotation.png&#34; alt=&#34;top down z rotation&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;As you can see the distribution of mass around the axis tends to dominate the inertia tensor due to the r&lt;sup&gt;2&lt;/sup&gt; term. The same mass, twice the distance from the axis, is four times more difficult to rotate!&lt;/p&gt;

&lt;h2&gt;Closed Form Solution&lt;/h2&gt;

&lt;p&gt;Exact equations are known for the moments of inertia of many &lt;a href=&#34;http://www.livephysics.com/physical-constants/mechanics-pc/moment-inertia-uniform-objects/&#34;&gt;common objects&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With a bit of math we can calculate closed form solutions for the moments of inertia of a go stone.&lt;/p&gt;

&lt;p&gt;To determine the exact equation for I&lt;sub&gt;y&lt;/sub&gt; we start with the moment of inertia for a solid disc:&lt;/p&gt;

&lt;p&gt;[latex]I = 1/2mr^2[/latex]&lt;/p&gt;

&lt;p&gt;Then we integrate again, effectively summing up the moments of inertia of an infinite number of thin discs making up the top half of the go stone.&lt;/p&gt;

&lt;p&gt;This leads to the following integral:&lt;/p&gt;

&lt;p&gt;[latex]\int_0^{h/2} (r^2-(y+r-h/2)^2)^2\,dy[/latex]&lt;/p&gt;

&lt;p&gt;With a little help from &lt;a href=&#34;http://wolframalpha.com&#34;&gt;Wolfram Alpha&lt;/a&gt; we get the following result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    float CalculateIy( const Biconvex &amp;amp; biconvex )
    {
        const float h = height;
        const float r = biconvex.GetSphereRadius();
        const float h2 = h * h;
        const float h3 = h2 * h;
        const float h4 = h3 * h;
        const float h5 = h4 * h;
        const float r2 = r * r;
        const float r3 = r2 * r;
        const float r4 = r3 * r;
        return pi * p * 
            ( 1/480.0f * h3 * 
              ( 3*h2 - 30*h*r + 80*r2 ) );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plugging in the values for a size 33 stone, we get 0.303588 which is close to the approximate solution 0.304776.&lt;/p&gt;

&lt;p&gt;Verifying exact solutions against numeric ones is a fantastic way to check your calculations.&lt;/p&gt;

&lt;p&gt;Can &lt;u&gt;you&lt;/u&gt; derive the equation for I&lt;sub&gt;x&lt;/sub&gt;?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Stone vs. Go Board</title>
      <link>http://173.255.195.190/gafferongames/post/go_stone_vs_go_board/</link>
      <pubDate>Fri, 22 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/go_stone_vs_go_board/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to &lt;a href=&#34;http://173.255.195.190/gafferongames/categories/virtual-go/&#34;&gt;&lt;strong&gt;Virtual Go&lt;/strong&gt;&lt;/a&gt;, my project to create a physically accurate computer simulation of a Go board and stones.&lt;/p&gt;

&lt;p&gt;In this series so far we&amp;rsquo;ve defined the shape of a go stone, rendered it using 3D graphics hardware and simulated how it moves in three dimensions.&lt;/p&gt;

&lt;p&gt;Our next goal is for the go stone to bounce and come to rest on the go board.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/corner-with-slate-and-shell-stones.jpg&#34; alt=&#34;slate and shell go stones&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Understandably, this is quite complicated, so in this article we&amp;rsquo;ll focus on the first step: detecting collisions between a go stone and the go board.&lt;/p&gt;

&lt;h2 id=&#34;voronoi-regions-and-the-minkowski-difference&#34;&gt;Voronoi Regions and The Minkowski Difference&lt;/h2&gt;

&lt;p&gt;First, lets assume that the go board is axis aligned and does not move.&lt;/p&gt;

&lt;p&gt;Next, because go stones are small relative to the go board, we can break down collision detection into regions which are treated differently.&lt;/p&gt;

&lt;p&gt;The common case is with the primary surface, the actual playing surface of the go board, so lets start by looking top-down at the go board and breaking it up into 2D voronoi regions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/voronoi-regions.png&#34; alt=&#34;voronoi regions&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Each voronoi region corresponds to a subspace where all points (x,z) in that region map to the same nearest feature on the go board. This gives us one region that maps points to the top surface of the go board, four regions that map to the sides, and four corner regions.&lt;/p&gt;

&lt;p&gt;If we were testing an infinitely small point against the go board, this would be enough, but we are colliding a go stone of a certain width and height.&lt;/p&gt;

&lt;p&gt;One simple way to incorporate the dimensions of the go stone is to offset the regions from the edge of the go board by the the go stone&amp;rsquo;s bounding sphere radius.&lt;/p&gt;

&lt;p&gt;This creates something like a poor man&amp;rsquo;s version of a minkowski difference:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/minkowski-difference.png&#34; alt=&#34;minkowski difference&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;We can now test the center of the go stone against these regions to quickly to categorize the type of &lt;i&gt;&lt;u&gt;potential&lt;/u&gt;&lt;/i&gt; collision.&lt;/p&gt;

&lt;h2 id=&#34;go-board-collision-cases&#34;&gt;Go Board Collision Cases&lt;/h2&gt;

&lt;p&gt;Although the go board has nine different regions there only three unique types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primary&lt;/li&gt;
&lt;li&gt;Edge&lt;/li&gt;
&lt;li&gt;Corner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Primary is the common case.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/board-primary-case.png&#34; alt=&#34;primary collision&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also the easiest to handle. The only possible collision is between the stone and the playing surface of the go board.&lt;/p&gt;

&lt;p&gt;Since the go board rests on the floor and cannot move we do not need to worry about collisions with the bottom surface. This means that we can consider the go board to be infinitely thick. This is extremely useful because it removes the possibility of fast moving go stones tunneling vertically through the board.&lt;/p&gt;

&lt;p&gt;Next is the edge case. This is more complicated because there is more than one way to collide in edge regions. Tests must be done between the go stone and the top plane, the side plane, and the side edge.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/board-side-case.png&#34; alt=&#34;side collision&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The corner case is more complicated still. Potential collisions include the top plane, the two side planes, the side edges adjacent to the corner, the vertical corner edge, and the corner point.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/board-corner-case.png&#34; alt=&#34;corner collision&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;go-stone-collision-cases&#34;&gt;Go Stone Collision Cases&lt;/h2&gt;

&lt;p&gt;When a go stone collides with another object there are three collision cases.&lt;/p&gt;

&lt;p&gt;The first is a collision on the top surface of the biconvex. This corresponds to a collision with a portion of the &lt;u&gt;bottom&lt;/u&gt; sphere that generated the go stone.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-collision-top.png&#34; alt=&#34;biconvex collision top&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Next is the bottom surface of the biconvex. This corresponds to the &lt;u&gt;top&lt;/u&gt; sphere.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-collision-bottom.png&#34; alt=&#34;biconvex collision bottom&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Finally, the collision point can be on the circle ring at the intersection of the two sphere surfaces.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-collision-side.png&#34; alt=&#34;biconvex collision side&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;separating-axis-test-sat&#34;&gt;Separating Axis Test (SAT)&lt;/h2&gt;

&lt;p&gt;We have 3 ways a stone can collide with any convex object, and 9 different regions that must be treated differently when testing vs. the go board. Within each region we have up to 7 different features on the go board that must be tested against 3 different features on the go stone.&lt;/p&gt;

&lt;p&gt;This is all rather complicated. How can we simplify it?&lt;/p&gt;

&lt;p&gt;The solution is to use the &lt;a href=&#34;https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169&#34;&gt;separating axis test&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The basic idea is that if we can find a plane that separates the stone and the board then they must not be colliding. This gives us a robust way of thinking about collision detection and makes testing for collision between objects more general and less prone to combinatorial explosion.&lt;/p&gt;

&lt;h2 id=&#34;calculating-the-support&#34;&gt;Calculating The Support&lt;/h2&gt;

&lt;p&gt;In order to use the separating axis test we must first write a function that determines the support of the go stone.&lt;/p&gt;

&lt;p&gt;The support is the projection of an object on to an axis. This can be difficult to think about in 3D, but for me it makes it easier to think of the axis not as a line, but as the normal of a plane.&lt;/p&gt;

&lt;p&gt;Then what we are really asking is: given this plane normal, what two planes from either side tightly bound the object like book-ends on a shelf?&lt;/p&gt;

&lt;p&gt;To calculate the support of a biconvex solid we must consider two cases.&lt;/p&gt;

&lt;p&gt;The first is when the go stone is vertical relative to the axis. Here it is reasonably easy. To calculate the support you simply calculate the intersection of the supports of the spheres used to generate the go stone. This makes a nice sort of intuitive sense seeing as the go stone is itself the intersection of two spheres.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-support-1.png&#34; alt=&#34;biconvex support case 1&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, this technique breaks down when the stone is horizontal relative to the axis because it fails to exclude the portion of the spheres that don&amp;rsquo;t contribute to the biconvex solid.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-support-wrong.png&#34; alt=&#34;biconvex support wrong&#34; width=&#34;50%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;What you need to do instead is to calculate the support of the circle edge.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-support-correct.png&#34; alt=&#34;biconvex support correct&#34; width=&#34;50%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The tricky part is detecting when the transition between these two cases occur. Here&amp;rsquo;s a diagram I created a while back when I first tried to work this out. If you look closely you can see the exact point where my head exploded:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-support-head-explode.jpg&#34; alt=&#34;head explode&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;And here&amp;rsquo;s a visualization of the end result:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/_fkLcJPJ6Wg&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Now we are ready to continue with the SAT for detecting collisions.&lt;/p&gt;

&lt;h2 id=&#34;primary-case&#34;&gt;Primary Case&lt;/h2&gt;

&lt;p&gt;With this support we can use a one-sided variant of the SAT to detect collision with the primary surface. We&amp;rsquo;re doing one-sided because we&amp;rsquo;re treating the go board as &amp;lsquo;infinitely thick&amp;rsquo; to avoid tunneling in the common case.&lt;/p&gt;

&lt;p&gt;First, we take the normal of the primary surface which is (0,1,0) and find the support for the go stone using this normal as the axis: s&lt;sub&gt;1&lt;/sub&gt; and s&lt;sub&gt;2&lt;/sub&gt;.&lt;/p&gt;

&lt;p&gt;Next, we calculate the projection of the board surface along the normal: t&lt;/p&gt;

&lt;p&gt;Then, if s&lt;sub&gt;1&lt;/sub&gt; &amp;lt;= t then the go stone is colliding with the go board:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/br3wVa0CIis&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Unfortunately, we detect the collision after the go stone has already penetrated the go board. There are many solutions for this problem: &lt;a href=&#34;http://jitter-physics.com/wordpress/?tag=continuous-collision-detection&#34;&gt;continuous collision detection&lt;/a&gt;, and &lt;a href=&#34;http://jitter-physics.com/wordpress/?tag=continuous-collision-detection&#34;&gt;speculative contacts&lt;/a&gt; being interesting avenues I may explore later on.&lt;/p&gt;

&lt;p&gt;But for now I just do the simplest and most pragmatic thing I can think of.&lt;/p&gt;

&lt;p&gt;I just push the stone out of the board along the axis.&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/98YB1ZE9gfQ&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;After I push the stone out, I recalculate the nearest point between the stone and board and use this as the contact point.&lt;/p&gt;

&lt;h2 id=&#34;edge-and-corner-cases&#34;&gt;Edge and Corner Cases&lt;/h2&gt;

&lt;p&gt;The primary surface case is easy because only one axis needs to be tested, but in corner and edge regions multiple axes must be tested for collision.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/multiple-axes-SAT.png&#34; alt=&#34;multiple axis SAT&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;This is where the SAT really starts to shine. Now instead of combinatorial explosion testing each of the features of the go stone vs. each of the features on the go board, we flatten both the go stone and the go board into support and test for collision one axis at a time.&lt;/p&gt;

&lt;p&gt;The separating axis test as applied as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Test all features in the region and determine if there is any separating axis&lt;/li&gt;
&lt;li&gt;If a separating axis exists then the go stone is not colliding with the board&lt;/li&gt;
&lt;li&gt;Otherwise the stone must be colliding with the board&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If the stone is colliding we must now work out what direction to push the stone out. I thought about this for a while and tried to come up with a simple pattern that worked.&lt;/p&gt;

&lt;p&gt;First, I tried pushing the stone out along the axis with the greatest amount of penetration, but this breaks down pretty severely in the case where a go stone approaches the go board from the side:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/multiple-axes-push-out-most-penetration.png&#34; alt=&#34;push out most penetration&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Next, I thought that perhaps I could use the previous position of the go stone and try to determine the direction that the stone is approaching from. But then I thought about go stones that were rotating rapidly and how this wouldn&amp;rsquo;t always be correct. Then I started thinking about corner and edge cases, and the longer I thought the more this approach seemed too complicated, like I was trying to invent my own half-assed continuous collision detection method that would probably only work half the time and be almost impossible to test.&lt;/p&gt;

&lt;p&gt;In the end I settled on the simplest solution I could come up with: push the go stone out along the axis with the &lt;u&gt;least&lt;/u&gt; amount of penetration.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/multiple-axes-push-out-least-penetration.png&#34; alt=&#34;push out least penetration&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;This seems counter-intuitive at first, but it has some nice parallels with other physical laws. Nature is lazy and always takes the shortest path. Nature does the &lt;em&gt;least amount of work&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We should probably do the same :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How The Go Stone Moves</title>
      <link>http://173.255.195.190/gafferongames/post/how_the_go_stone_moves/</link>
      <pubDate>Thu, 21 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/how_the_go_stone_moves/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to &lt;a href=&#34;http://173.255.195.190/gafferongames/categories/virtual-go/&#34;&gt;&lt;strong&gt;Virtual Go&lt;/strong&gt;&lt;/a&gt;, my project to create a physically accurate computer simulation of a Go board and stones.&lt;/p&gt;

&lt;p&gt;In previous articles we mathematically defined the shape of a go stone and tessellated its shape so it can be drawn with 3D graphics hardware.&lt;/p&gt;

&lt;p&gt;Now we want to make the go stone move, obeying Newton&amp;rsquo;s laws of motion so the simulation is physically accurate. The stone should be accelerated by gravity and fall downwards. I also want the stone to rotate so it tumbles realistically as it falls through the air.&lt;/p&gt;

&lt;h2 id=&#34;the-rigid-body-assumption&#34;&gt;The Rigid Body Assumption&lt;/h2&gt;

&lt;p&gt;Try biting down on a go stone and you&amp;rsquo;ll agree: go stones are very, very hard.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/slate-and-shell-corner-up-close.jpg&#34; alt=&#34;slate and shell go stones&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Golf balls are pretty hard too, but if you look at a golf ball being hit by a club in super-slow motion, you&amp;rsquo;ll see that it deforms considerably during impact.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/golf-ball-compression-during-impact.jpg&#34; alt=&#34;golf ball compression during impact&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The same thing happens to all objects in the real world to some degree. Nothing is truly rigid. No real material is so hard that it never deforms.&lt;/p&gt;

&lt;p&gt;But this is not the real world. This is Virtual Go. It&amp;rsquo;s a simulation and here we are free to make whatever assumptions we want. And the smartest simplification we can make at this point is to assume that the go stone is perfectly rigid and does not deform under any circumstance.&lt;/p&gt;

&lt;p&gt;This is known as the &lt;a href=&#34;https://en.wikipedia.org/wiki/Rigid_body&#34;&gt;rigid body&lt;/a&gt; assumption.&lt;/p&gt;

&lt;h2 id=&#34;working-in-three-dimensions&#34;&gt;Working in Three Dimensions&lt;/h2&gt;

&lt;p&gt;Because the go stones are rigid, all we need to represent their current position is the position of the center. As the center moves, so does the rest of the stone.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-rigid-body-center-P.png&#34; alt=&#34;biconvex go stone rigid body center&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll represent this position using a three dimensional vector &lt;b&gt;P&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define the axes so we know what the x,y,z components of P mean:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Positive x is to the right&lt;/li&gt;
&lt;li&gt;Positive y is up&lt;/li&gt;
&lt;li&gt;Positive z is into the screen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is what is known as a left-handed coordinate system. So called because I can use the fingers on my left hand to point out each positive axis direction without breaking them.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/coordinate-systems-left-and-right-handed.png&#34; alt=&#34;left and right handed coordinate systems&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve chosen a left-handed coordinate system purely on personal preference. Also, I&amp;rsquo;m left-handed and I like my fingers :)&lt;/p&gt;

&lt;h2 id=&#34;linear-motion&#34;&gt;Linear Motion&lt;/h2&gt;

&lt;p&gt;Now we want to make the stone move.&lt;/p&gt;

&lt;p&gt;To do this we need the concept of velocity. Velocity is also a vector but it&amp;rsquo;s not a point like P. Think of it more like a direction and a length. The direction of the velocity vector is the direction the stone is moving and the length is the speed it&amp;rsquo;s moving in some unit per-second. Here I&amp;rsquo;ll use centimeters per-second because go stones are small.&lt;/p&gt;

&lt;p&gt;For example, if we the stone to move to the right at a rate of 5 centimeters per-second then the velocity vector is (5,0,0).&lt;/p&gt;

&lt;p&gt;To make the stone move, all we have to do is add the velocity to the position once per-second:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/d7H8MSrOBko&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;While this works, it&amp;rsquo;s not particularly exciting. We&amp;rsquo;d like the stone to move much more smoothly. Instead of updating once per-second, let&amp;rsquo;s update 60 times per-second or 60 fps (frames per-second). Rather than taking one big step, we&amp;rsquo;ll take 60 smaller steps per-second, each step being &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;60&lt;/sub&gt; of the velocity.&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/yK_Zh2u3D0w&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;You can generalize this to any framerate with the concept of delta time or &amp;ldquo;dt&amp;rdquo;. To calculate delta time invert frames per second: dt = 1/fps and you have the amount of time per-frame in seconds. Next, multiply velocity by delta time and you have the change in position per-frame.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    const float fps = 60.0f;
    const float dt = 1 / fps;
    while ( !quit )
    {
        stone.rigidBody.position += stone.rigidBody.velocity * dt;
        RenderStone( stone );
        UpdateDisplay();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is actually a very simple type of &lt;a href=&#34;https://en.wikipedia.org/wiki/Euler_method&#34;&gt;numerical integration&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;gravitational-acceleration&#34;&gt;Gravitational Acceleration&lt;/h2&gt;

&lt;p&gt;Next we want to add gravity.&lt;/p&gt;

&lt;p&gt;To do this we need to change velocity each frame by some amount downwards due to gravity. Change in velocity is known as acceleration. Gravity provides a constant acceleration of 9.8 meters per-second, per-second, or in our case, 98 centimeters per-second, per-second because we&amp;rsquo;re working in centimeters.&lt;/p&gt;

&lt;p&gt;Acceleration due to gravity is also a vector. Since gravity pulls objects down, the acceleration vector is (0,-98,0). Remember, +y axis is up, so -y is down.&lt;/p&gt;

&lt;p&gt;So how much does gravity accelerate the go stone in 1/60th of a second? Well, 98 * &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;60&lt;/sub&gt; = 1.633&amp;hellip; Hey wait. This is exactly what we did with velocity to get position!&lt;/p&gt;

&lt;p&gt;Yes it is. It&amp;rsquo;s exactly the same. Acceleration integrates to velocity just like velocity integrates to position. And both are multiplied by dt to find the amount to add per-frame, where dt = 1/fps.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    float gravity = 9.8f * 10;
    float fps = 60.0f;
    float dt = 1 / fps;
    while ( !quit )
    {
        stone.rigidBody.velocity += vec3f( 0, -gravity, 0 ) * dt;
        stone.rigidBody.position += stone.rigidBody.velocity * dt;
        RenderStone( stone );
        UpdateDisplay();
    }    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the result:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/nIMK8V6b84I&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;As you can see, now that we&amp;rsquo;ve added acceleration due to gravity the go stone moves in a parabola just like it does in the real world when it&amp;rsquo;s thrown.&lt;/p&gt;

&lt;h2 id=&#34;angular-motion&#34;&gt;Angular Motion&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s make the stone rotate!&lt;/p&gt;

&lt;p&gt;First we have to define how we represent the orientation of the stone. For this we&amp;rsquo;ll use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation&#34;&gt;quaternion&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Next we need the angular equivalent of velocity known as&amp;hellip; wait for it&amp;hellip; angular velocity. This too is a vector aka a direction and a length. It&amp;rsquo;s direction is the axis of rotation and the length is the rate of rotation in radians per-second. One full rotation is 2*pi radians or 360 degrees so if the length of the angular velocity vector is 2*pi the object rotates around the axis once per-second.&lt;/p&gt;

&lt;p&gt;Because we&amp;rsquo;re using a left handed coordinate system the direction of rotation is clockwise about the positive axis. You can remember this by sticking your thumb of your left hand in the direction of the axis of rotation and curling your fingers. The direction your fingers curl is the direction of rotation. Notice if you do the same thing with your right hand the rotation is the other way.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/rotation-direction-hand-thumb.png&#34; alt=&#34;rotation direction left and right hands&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;How do we integrate orientation from angular velocity? Orientation is a quaternion and angular velocity is a vector. We can&amp;rsquo;t just add them together.&lt;/p&gt;

&lt;p&gt;The solution requires a reasonably solid understanding of quaternion math and how it relates to complex numbers. Long story short, we need to convert our angular velocity into a quaternion form and then we can integrate that just like we integrate any other vector. For a full derivation of this result please refer to &lt;a href=&#34;https://fgiesen.wordpress.com/2012/08/24/quaternion-differentiation/&#34;&gt;this excellent article&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is the code I use to convert angular velocity into quaternion form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    inline quat4f AngularVelocityToSpin( quat4f orientation, vec3f angularVelocity )
    {
        const float x = angularVelocity.x();
        const float y = angularVelocity.y();
        const float z = angularVelocity.z();
        return 0.5f * quat4f( 0, x, y, z ) * 
            orientation;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And once I have this spin quaternion, I can integrate it to find the change in the orientation quaternion just like any other vector.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    const float fps = 60.0f;
    const float dt = 1 / fps;
    while ( !quit )
    {
        quat4f spin = AngularVelocityToSpin( 
            stone.rigidBody.orientation, 
            stone.rigidBody.angularVelocity );
        stone.rigidBody.orientation += spin * iteration_dt;
        stone.rigidBody.orientation = normalize( stone.rigidBody.orientation );
        RenderStone( stone );
        UpdateDisplay();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference is that after integration I renormalize the quaternion to ensure it doesn&amp;rsquo;t drift from unit length, otherwise it stops representing a rotation.&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/sR4G-_wIeuc&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Yep. That go stone is definitely rotating.&lt;/p&gt;

&lt;h2 id=&#34;why-quaternions&#34;&gt;Why Quaternions?&lt;/h2&gt;

&lt;p&gt;Graphics cards typically represent rotations with matrices, so why are we using quaternions when calculating physics instead of 4x4 matrices? Aren&amp;rsquo;t we bucking the trend a bit here?&lt;/p&gt;

&lt;p&gt;Not really. There are many good reasons to work with quaternions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s easier to integrate angular velocity using a quaternion than a 3x3 matrix&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Normalizing a quaternion is faster than orthonormalizing a 3x3 matrix&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s really easy to interpolate between two quaternions&lt;/li&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll still use matrices but as a secondary quantity. This means that each frame after we integrate we convert the quaternion into a 3x3 rotation matrix and combine it with the position into a 4x4 rigid body matrix and its inverse like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mat4f RigidBodyMatrix( vec3f position, 
                           quat4f rotation )
    {
        mat4f matrix;
        rotation.toMatrix( matrix );
        matrix.value.w = simd4f_create( position.x(), 
                                        position.y(), 
                                        position.z(), 
                                        1 );
        return matrix;
    }

    mat4f RigidBodyInverse( const mat4f &amp;amp; matrix )
    {
        mat4f inverse = matrix;
        vec4f translation = matrix.value.w;
        inverse.value.w = simd4f_create(0,0,0,1);
        simd4x4f_transpose_inplace( &amp;amp;inverse.value );
        vec4f x = matrix.value.x;
        vec4f y = matrix.value.y;
        vec4f z = matrix.value.z;
        inverse.value.w = 
            simd4f_create( -dot( x, translation ),
                           -dot( y, translation ),
                           -dot( z, translation ),
                           1.0f );
        return inverse;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now whenever we transform vectors want to go in/out of stone body space we&amp;rsquo;ll use this matrix and its inverse. It&amp;rsquo;s the best of both worlds.&lt;/p&gt;

&lt;h2 id=&#34;bringing-it-all-together&#34;&gt;Bringing It All Together&lt;/h2&gt;

&lt;p&gt;The best thing about rigid body motion is that you can calculate linear and angular motion separately and combine them together and it just works.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the final code with linear and angular motion combined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const float gravity = 9.8f * 10;
const float fps = 60.0f;
const float dt = 1 / fps;

while ( !quit )
{
    stone.rigidBody.velocity += vec3f( 0, -gravity, 0 ) * dt;

    stone.rigidBody.position += stone.rigidBody.velocity * dt;

    quat4f spin = 
        AngularVelocityToSpin( 
            stone.rigidBody.orientation, 
            stone.rigidBody.angularVelocity );

    stone.rigidBody.orientation += spin * dt;
    stone.rigidBody.orientation = normalize( stone.rigidBody.orientation );

    RenderStone( stone );

    UpdateDisplay();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the end result:&lt;/p&gt;

&lt;div class=&#34;video_container&#34;&gt;
&lt;iframe src=&#34;//www.youtube.com/embed/gmZGktbTAGA&#34; 
frameborder=&#34;0&#34; allowfullscreen class=&#34;video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;I think this is fairly convincing. The go stone is moving quite realistically.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mission accomplished!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;todo: link to next article&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tessellating The Go Stone</title>
      <link>http://173.255.195.190/gafferongames/post/tessellating_the_go_stone/</link>
      <pubDate>Wed, 20 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/tessellating_the_go_stone/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to &lt;a href=&#34;http://173.255.195.190/gafferongames/categories/virtual-go/&#34;&gt;&lt;strong&gt;Virtual Go&lt;/strong&gt;&lt;/a&gt;, my project to create a physically accurate computer simulation of a Go board and stones.&lt;/p&gt;

&lt;p&gt;In this article we want to draw the go stone using &lt;a href=&#34;http://www.opengl.org&#34;&gt;OpenGL&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately we can&amp;rsquo;t just tell the graphics card, &amp;ldquo;Hey! Please draw the intersection of two spheres with radius r and d apart with a bevel torus r&lt;sub&gt;1&lt;/sub&gt; and r&lt;sub&gt;2&lt;/sub&gt;!&amp;ldquo;. Modern 3D graphics cards work by drawing triangles, so we have to take our mathematical definition of the go stone and turn it into a set of triangles that the graphics card can render.&lt;/p&gt;

&lt;p&gt;This is called tessellation and there are several different ways to do it.&lt;/p&gt;

&lt;h2 id=&#34;longitude-and-lattitude&#34;&gt;Longitude And Lattitude&lt;/h2&gt;

&lt;p&gt;The first way that I tried was to consider sphere rendering like a globe with longitude/latitude. I started with a ring around the &amp;lsquo;equator&amp;rsquo; of the go stone, stepping these rings up to the top of the sphere like the north pole on a globe.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/naive-tesselation-side-view.gif&#34; alt=&#34;naive tesselation side view&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, just like longitude/latitude on a globe, tessellating this way leads to very distorted mapping around the pole and a lot of wasted triangles:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/inefficient-tesselation-at-pole.gif&#34; alt=&#34;inefficient tesselation at pole&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;triangle-subdivision&#34;&gt;Triangle Subdivision&lt;/h2&gt;

&lt;p&gt;The next method is triangle subdivision. You start with an approximate shape then subdivide each triangle into four smaller triangles recursively like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/sphere-tessellation.gif&#34; alt=&#34;sphere tessellation&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Since the go stone only needs the top &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; or &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; of a sphere, I didn&amp;rsquo;t want to subdivide a whole sphere only to throw most of it away. So I designed my own subdivision algorithm to generate only the top section of a sphere.&lt;/p&gt;

&lt;p&gt;After some trial and error I found that a pentagon plus a center vertex at the pole of the sphere was a good initial generator that minimized the distortion that occurs during subdivision. The only tricky part is that when subdividing you need to keep track of whether the edge is a sphere edge or a circle edge, as the subdivided vertex must be projected differently.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/generating-shape.gif&#34; alt=&#34;generating shape&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;With this technique I was able to generate a much more efficient tessellation:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/regular-tessellation.gif&#34; alt=&#34;regular tessellation&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;tessellating-the-bevel&#34;&gt;Tessellating The Bevel&lt;/h2&gt;

&lt;p&gt;Now we need to tesselate the bevel. To do this I take the vertices which form the circle edge at the bottom of the top sphere surface and calculate the angle of each vertex about the y axis. I then use these angles to sweep around the torus ensuring that the torus vertices weld perfectly with the top and bottom sphere sections.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/go-stone-with-bevel.gif&#34; alt=&#34;go stone with bevel&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;vertex-welding&#34;&gt;Vertex Welding&lt;/h2&gt;

&lt;p&gt;Due to how recursive subdivision works a lot of duplicate vertices are generated. I&amp;rsquo;d rather not have the graphics card waste time transforming the same vertex over and over, so as I add vertices to the mesh I hash vertex positions into a 3D grid (~1mm cells) and reuse an existing vertex if the position and normals match within some small epsilon value.&lt;/p&gt;

&lt;p&gt;With vertex welding the reduction in vertices is dramatic: 53000 to just 6500. Fewer vertices means I can render more go stones, which is handy because there can be up to 361 of them on a 19x19 go board!&lt;/p&gt;

&lt;p&gt;For more information on vertex welding please refer to the discussion in &lt;a href=&#34;http://www.amazon.com/Real-Time-Collision-Detection-Interactive-Technology/dp/1558607323/ref=sr_1_1?ie=UTF8&amp;qid=1363029675&amp;sr=8-1&amp;keywords=real+time+collision+detection&#34;&gt;Real-Time Collision Detection&lt;/a&gt; by &lt;a href=&#34;http://realtimecollisiondetection.net/blog/&#34;&gt;Christer Ericson&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;todo: link to next article&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shape of The Go Stone</title>
      <link>http://173.255.195.190/gafferongames/post/shape_of_the_go_stone/</link>
      <pubDate>Tue, 19 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/shape_of_the_go_stone/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to &lt;a href=&#34;http://173.255.195.190/gafferongames/categories/virtual-go/&#34;&gt;&lt;strong&gt;Virtual Go&lt;/strong&gt;&lt;/a&gt;, my project to create a physically accurate computer simulation of a Go board and stones.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve ever played Go, you know that a biconvex go stone has an interesting wobble when it&amp;rsquo;s placed on the board. This wobble is a direct consequence of its unique shape.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to reproduce this wobble in Virtual Go, so let&amp;rsquo;s to spend some time studying their shape, so we can capture and simulate it with a computer :)&lt;/p&gt;

&lt;h2 id=&#34;slate-and-shell&#34;&gt;Slate And Shell&lt;/h2&gt;

&lt;p&gt;In Japan, Go stones are traditionally made out of slate and clam shell.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/slate-and-shell-in-ko.jpg&#34; alt=&#34;slate and shell in ko&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Clam shell stones come in several grades of quality. The highest being yuki or &amp;ldquo;snow&amp;rdquo; grade with fine, regularly spaced lines.&lt;/p&gt;

&lt;p&gt;Go stones also come in different sizes. In general, the thicker the stone, the more expensive it is, as only a small portion of the clam shell is suitable for making them.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/go-stone-side-profile-sizes.png&#34; alt=&#34;go stone side profile sizes&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;At first glance the go stone looks like an ellipse, but side-on you can see this is not the case. This shape is called a &lt;em&gt;biconvex solid&lt;/em&gt;. I find this shape interesting because it is the intersection of two spheres.&lt;/p&gt;

&lt;p&gt;We can study this shape by looking at the intersection of two circles:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex.gif&#34; alt=&#34;biconvex&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;I quickly noticed that by varying the radius of the circles and the distance between their centers, I could generate go stones of different sizes.&lt;/p&gt;

&lt;p&gt;This is interesting, but when creating a go stone I don&amp;rsquo;t really want it to be parameterized this way. Instead I&amp;rsquo;d like to say, &amp;ldquo;Hey, I would like a stone of this width and height&amp;rdquo; and have a function that calculates the radius of the circles and how far apart they should be to generate that stone.&lt;/p&gt;

&lt;p&gt;To write this function we first need to do some math:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/biconvex-unknowns.png&#34; alt=&#34;biconvex unknowns&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;First notice that the point Q lies on the generating circle, so the line CQ has length r:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;todo: obviously I have a bunch of work to get the latex equations ported across to Hugo. I&amp;rsquo;m researching different options&amp;hellip;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]d + h/2 = r[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]d = r - h/2[/latex]&lt;/p&gt;

&lt;p&gt;The point P is also on the generating circle so the green line CP has length r as well. Using Pythagoras theorem and substituting for d:&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]r^2 = d^2 + (w/2)^2[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]r^2 = ( r - h/2 )^2 + (w/2)^2[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]r^2 = ( h^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; - hr + r^2 ) + w^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]r^2 = h^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; - hr + r^2 + w^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]0 = h^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; - hr + 0 + w^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]hr = h^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; + w^&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]r = ( h^2 + w^2 ) / 4h[/latex]&lt;/p&gt;

&lt;p&gt;Which gives us everything we need to write the function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    void calculateBiconvex( float w,  
                            float h, 
                            float &amp;amp; r, 
                            float &amp;amp; d )
    {
        r = ( w*w + h*h ) / ( 4*h );
        d = r - h/2;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can mathematically define a go stone parameterized by its width and height. There is just one problem: the edge is very sharp!&lt;/p&gt;

&lt;p&gt;To make our stone aesthetically pleasing, lets round the edge with a bevel. Otherwise, you might cut yourself virtually when you play with it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/go-stone-smooth-bevel.jpg&#34; alt=&#34;go stone smooth bevel&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s parameterize the bevel by its height b:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/bevel-b.gif&#34; alt=&#34;torus bevel height b&#34; width=&#34;75%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;In three dimensions the bevel is actually a torus (donut) around the edge of the go stone. We need to calculate the major and minor radii r&lt;sub&gt;1&lt;/sub&gt; and r&lt;sub&gt;2&lt;/sub&gt; of the torus as a function of b and the dimensions of the go stone:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/bevel-math-1.gif&#34; alt=&#34;bevel math part 1&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The key to solving this is to realize that if the go stone and the bevel are to match perfectly then the tangent of the two circles must be equal at the point P.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt;Update&lt;/em&gt;: A few years later and it occurs to me that it would be even more beautiful if the second derivative matched at this intersection as well. Is this possible in general, or must the generating spheres become to ellipses to make this happen? I suspect this is the case. Mathematicians who play Go, &lt;a href=&#34;http://173.255.195.190/gafferongames/contact&#34;&gt;please let me know your thoughts&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/bevel-math-2.gif&#34; alt=&#34;bevel math part 2&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;

&lt;p&gt;If the tangent is equal then the normal must be equal as well. This means that the center of the bevel circle lies at the intersection of the line CP and the x axis.&lt;/p&gt;

&lt;p&gt;We already know C so if we can find the point P then we can find this intersection point. Once we know the intersection point we can find r&lt;sub&gt;1&lt;/sub&gt; and r&lt;sub&gt;2&lt;/sub&gt;.&lt;/p&gt;

&lt;p&gt;Since P is at the start of the bevel:&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]P_y = b/2[/latex]&lt;/p&gt;

&lt;p&gt;Because P lies on the biconvex circle with center C and radius r we can use the equation of the circle to find x as a function of y:&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]x^2 + y^2 = r^2[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]x = \sqrt{ r^2 - y^2 }[/latex]&lt;/p&gt;

&lt;p&gt;We need y relative to the circle center C, not in go stone coordinates, so we add d and substitute y&amp;rsquo; for y:&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]y&amp;rsquo; = b/2 + d[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]P_x = \sqrt{ r^2 - ( b/2 + d )^2 }[/latex]&lt;/p&gt;

&lt;p&gt;We can now find r&lt;sub&gt;1&lt;/sub&gt; by similar triangles:&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]r_1/P_x = d / ( d + b/2 )[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]r_1 = P_x d / ( d + b/2 )[/latex]&lt;/p&gt;

&lt;p&gt;and q by Pythagoras theorem:&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]q^2 = d^2 + r_1^2[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]q = \sqrt{ d^2 + r_1^2 }[/latex]&lt;/p&gt;

&lt;p&gt;Because line CP has length r and substituting for q:&lt;/p&gt;

&lt;p&gt;[latex size=&amp;ldquo;2&amp;rdquo;]q + r_2 = r[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]r_2 = r - q[/latex]
[latex size=&amp;ldquo;2&amp;rdquo;]r_2 = r - \sqrt{ d^2 + r_1^2 }[/latex]&lt;/p&gt;

&lt;p&gt;Now we have everything we need to write the function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    void calculate_bevel( float r, float d, float b, 
                          float &amp;amp; r1, float &amp;amp; r2 )
    {
        const float y = b/2 + d;
        const float px = sqrt( r*r - y*y );
        r1 = px * d / ( d + b/2 ); 
        r2 = r - sqrt( d*d + r1*r1 );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can calculate the bevel torus to round off any go stone we create as the intersection of two spheres.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;todo: link to next article&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Virtual Go</title>
      <link>http://173.255.195.190/gafferongames/post/introduction_to_virtual_go/</link>
      <pubDate>Mon, 18 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://173.255.195.190/gafferongames/post/introduction_to_virtual_go/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Hi, I&amp;rsquo;m Glenn Fiedler. Welcome to &lt;a href=&#34;http://173.255.195.190/gafferongames/categories/virtual-go/&#34;&gt;&lt;strong&gt;Virtual Go&lt;/strong&gt;&lt;/a&gt;, my project to create a physically accurate computer simulation of a Go board and stones.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m a professional game programmer with 15 years experience in the game industry. Over the years I&amp;rsquo;ve worked for Irrational Games, Team Bondi, Pandemic Studios, Sony Santa Monica and most recently Respawn Entertainment. During my career I&amp;rsquo;m extremely proud to have worked on such games as &amp;lsquo;Freedom Force&amp;rsquo;, &amp;lsquo;L.A. Noire&amp;rsquo;, &amp;lsquo;Journey&amp;rsquo;, &amp;lsquo;God of War: Ascension&amp;rsquo; and &amp;lsquo;Titanfall&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;In my spare time I&amp;rsquo;m also an avid player of the board game &lt;a href=&#34;https://en.wikipedia.org/wiki/Go_(game)&#34;&gt;Go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/go-board-outside-cafe.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A personal project I&amp;rsquo;ve always dreamed of combines the things I love: the game of Go, graphics programming, physics simulation and network programming.&lt;/p&gt;

&lt;p&gt;The end result I hope to achieve is a beautiful real-time computer rendering of a go board and stones with photorealistic visuals and the laws of physics defining all interactions between the go stones and the board. To Go players reading this, yes, I do aim to reproduce that unique &amp;lsquo;wobble&amp;rsquo; and feel you are familiar with when placing a stone on the board.&lt;/p&gt;

&lt;p&gt;During the course of this article series I&amp;rsquo;m going to build this project entirely from scratch and include &lt;u&gt;you&lt;/u&gt; in on all the details of building it as a tutorial. I believe in sharing knowledge and my hope is you can follow this project and understand the passion I bring to it and perhaps learn a few things along the way.&lt;/p&gt;

&lt;p&gt;If you already play Go and want to get right in to the details of building the simulation, I would recommend skipping ahead to the next article in the series: &lt;a href=&#34;http://173.255.195.190/gafferongames/post/shape_of_the_go_stone/&#34;&gt;Shape Of The Go Stone&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Otherwise, if you would like a quick introduction to Go, please read on!&lt;/p&gt;

&lt;h2 id=&#34;the-game-of-go&#34;&gt;The Game of Go&lt;/h2&gt;

&lt;p&gt;Go is a board game that originated in ancient China.&lt;/p&gt;

&lt;p&gt;Today it is played worldwide but has a particularly strong following in China, Japan and Korea. It is not particularly well known in the West, although it has featured in popular culture in the movie &amp;ldquo;A Beautiful Mind&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/old-men-playing-go.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Go is played on a grid with black and white stones. It is played by two people, each taking turns to place a stone of their color at one of the intersection points on the grid. Once placed on the board, stones do not move.&lt;/p&gt;

&lt;p&gt;Each stone on the board has a number of liberties equal to the number of lines radiating out from it on the grid. A stone in the middle of the board has four liberties, a stone on the side has three, a stone in the corner has just two.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/go-board-liberties-9x9.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If the opponent is able to surround all the liberties with stones of the opposite color, the stone is removed from the board.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/capture-stones-9x9.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When stones of the same color are placed horizontally or vertically next to each other they become logically connected and form a &amp;ldquo;group&amp;rdquo; with its own set of liberties. For example, a group of two stones in the center has 6 liberties, while the same group on the side has only 4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/go-board-group-of-two-liberties-9x9.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A group may be captured if all of its liberties are blocked with stones of the opposite color. When a group is captured it is removed from the board as a unit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/capture-groups-of-two-9x9.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Of course it is not so easy to surround your opponents stones because they get to place stones too :)&lt;/p&gt;

&lt;p&gt;For example, a single black stone in the center with just one liberty remaining is in a situation known as &amp;ldquo;Atari&amp;rdquo;, but black can escape by extending to form a group of two stones. Now the black group has three liberties and can extend to create more liberties faster than they can be taken away.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://173.255.195.190/gafferongames/img/virtualgo/atari-run-away-9x9.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It follows that it&amp;rsquo;s not really possible to capture all of your opponents stones or for them to capture all of yours. Instead, you must coexist on the board with stones of the other color and find a way to surround more points of territory than your opponent.&lt;/p&gt;

&lt;p&gt;It sounds simple but as you play Go you&amp;rsquo;ll notice beautiful complexity emerging like a fractal: life and death - stones living even though surrounded, liberty races, seki or &amp;ldquo;dual life&amp;rdquo;, the ladder, ko, the snapback, playing under the stones, the monkey jump, the bamboo joint, the tiger mouth.&lt;/p&gt;

&lt;p&gt;So many beautiful properties from such simple rules. Truly an amazing game!&lt;/p&gt;

&lt;p&gt;Please visit &lt;a href=&#34;http://playgo.to/iwtg/en/&#34;&gt;The Interactive Way To Go&lt;/a&gt; if you would like to learn more.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>